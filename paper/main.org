#+title: Congestion-Free Network Updates: Algorithms and Complexity

#+startup: latexpreview

#+latex_class: book
#+latex_class_options: [fontsize=11pt,paper=a4]

#+latex_header: \input{preamble}

#+caption: Table of notations
| [[notation:reachability-relation][\(\leq_G\)]]           | The reachability relation for directed graph \(G\)                                        |
| [[notation:block-update][\(b(v,P)\)]]           | The \(P\)-block containing vertex \(v\)                                                   |
| [[notation:flow-pair-block][\(P(b)\)]]             | The flow pair \(P\) such that block \(b\) is a \(P\)-block                                |
| [[notation:start-block][\(\mathcal{S}(b)\)]]   | The least vertex in block \(b\) w.r.t. reachability relation \(\leq_{P(b)^o\cup P(b)^u}\) |
| [[notation:p-blocks][\(B^P(G)\)]]           | The set of \(P\)-blocks                                                                   |
| [[notation:blocks][\(B(G)\)]]             | The set of blocks                                                                         |
| [[notation:block-sequence-round-block][\(\mathcal{B}(b)\)]]   | The round in which block \(b\) is updated                                                 |
| [[notation:block-sequence-round-update][\(\mathcal{B}(v,P)\)]] | The round in which block \(b(v,P)\) is updated                                            |
| [[notation:b-sub-i][\(B_i\)]]              | The set of blocks updated before or in the \(i\)-th round                                 |
| [[notation:permutation][\(S(\pi)\)]]              | The set of which \(\pi\) is a permutation                                                 |
| [[notation:permutation][\(\lvert\pi\rvert\)]]     | The number of elements of permutation \(\pi\)                                             |
| [[notation:permutation][\(\pi_i\)]]               | The \(i\)-th element of permutation \(\pi\)                                               |
| [[notation:permutation][\(\pi(x)\)]]              | The position of element \(x\) in permutation \(\pi\)                                     |

* Preliminaries

** Blocks

#+name: notation:reachability-relation
#+begin_notation
For a directed graph \(G\), \(\leq_G=E(G)^*\) denotes the reachability relation of \(G\).
That is, for every two vertices \(u,v\in V(G)\), \(u\leq_Gv\) iff there is a path in \(G\) from \(u\) to \(v\).
#+end_notation

Notice that for every directed graph \(G\),

1. reachability relation \(\leq_G\) is a partial order,

2. if \(G\) is a DAG, then \(\leq_G\) is antisymmetric, and

3. if \(G\) is a path graph, then \(\leq_G\) is a total order.

#+name: defn:block
#+begin_defn
Let \(G=(V,E,\mathcal{P},s,t,c)\) be an update flow network and \(P\in\mathcal{P}\) be a flow pair.
Let \(v_1,\dots,v_{\ell}\) be the set \(V(P^o\cap P^u)\) ordered w.r.t. \(\leq_{P^o\cup P^u}\).
For every \(i\in[\ell-1]\), we define the \(i\)-th /\(P\)-block/ as \(b_i^P=\{v\mid v_i\leq_{P^o\cup P^u}v\leq_{P^o\cup P^u}v_{i+1}\}\).
#+end_defn

#+begin_remark
There are multiple issues with this definition (see [[file:../README.org::*Open problems]]).
#+end_remark

#+name: notation:block-update
#+begin_notation
For a flow pair \(P\) and a vertex \(v\in V(P)\), \(b(v,P)\) denotes the \(P\)-block containing \(v\).
#+end_notation

#+name: notation:start-block
#+begin_notation
For a block \(b\), \(P(b)\) denotes the flow pair \(P\) such that \(b\) is a \(P\)-block.
#+end_notation

#+name: notation:flow-pair-block
#+begin_notation
For a block \(b\), \(\mathcal{S}(b)\) denotes the /start/ of \(b\), that is, the least vertex in \(b\) w.r.t. \(\leq_{P(b)^o\cup P(b)^u}\).
#+end_notation

#+name: notation:p-blocks
#+begin_notation
For an update flow network \(G\) and a flow pair \(P\), \(B^P(G)\) denotes the set of \(P\)-blocks.
#+end_notation

#+name: notation:blocks
#+begin_notation
For an update flow network \(G\), \(B(G)=\bigcup_{P\in\mathcal{P}}B^P(G)\) denotes the set of blocks.
#+end_notation

** Block Sequences

#+name: defn:block-sequence
#+begin_defn
A /block sequence/ \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) is an ordered partition of the set of blocks.
#+end_defn

#+name: remark:block-sequence
#+begin_remark
We may ignore all blocks containing less than three vertices.
#+end_remark

- [ ] Flesh out and argue why.

#+name: notation:block-sequence-round-block
#+begin_notation
For a block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) and a block \(b\), \(\mathcal{B}(b)\) denotes the index \(i\in[\ell]\) such that \(b\) is contained in \(\mathscr{B}_i\).
#+end_notation

#+name: notation:block-sequence-round-update
#+begin_notation
For a block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\), a flow pair \(P\), and a vertex \(v\in V(P)\), \(\mathcal{B}(v,P)=\mathcal{B}(b(v,P))\) denotes the index \(i\in[\ell]\) such that block \(b(v,P)\) is contained in \(\mathscr{B}_i\).
#+end_notation

#+name: notation:b-sub-i
#+begin_notation
For a block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) and an index \(i\in[\ell]\), \(B_i=\bigcup_{j\leq i}\mathscr{B}_j\) denotes the set of blocks updated before or in the \(i\)-th round.
#+end_notation

#+name: defn:alpha-block
#+begin_defn
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence.
For a flow pair \(P\), an edge \((u,v)\in E(P^o\cup P^u)\), and an index \(i\in[\ell]\), the /activation label/ \(\alpha_P((u,v),B_i)\) is defined as follows:
\[\alpha_P((u,v),B_i)=
\begin{cases}
\mathrm{active} & \text{if }(u,v)\in E(P^o)\text{ and }b(u,P)\notin B_i\\
\mathrm{active} & \text{if }(u,v)\in E(P^u)\text{ and }b(u,P)\in B_i\\
\mathrm{inactive} & \text{otherwise}.
\end{cases}\]
#+end_defn

#+name: lem:alpha-block-cases-edge
#+begin_lem
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence, \(P\) be a flow pair, \((u,v)\in E(P^o\cup P^u)\), and \(i\in[\ell]\).
Then:

1. If \((u,v)\in E(P^o\setminus P^u)\), then
   \[\alpha_P((u,v),B_i)=
   \begin{cases}
   \mathrm{active} & i<\mathcal{B}(u,P)\\
   \mathrm{inactive} & i\geq\mathcal{B}(u,P).
   \end{cases}\]
   
2. If \((u,v)\in E(P^o\cap P^u)\), then \(\alpha_P((u,v)B_i)=\mathrm{active}\).

3. If \((u,v)\in E(P^u\setminus P^o)\), then
   \[\alpha_P((u,v),B_i)=
   \begin{cases}
   \mathrm{active} & i\geq\mathcal{B}(u,P)\\
   \mathrm{inactive} & i<\mathcal{B}(u,P).
   \end{cases}\]
#+end_lem

#+name:
#+begin_notation
For a flow pair \(P\) and a \(P\)-block \(b\), \(U(b)=\{(v,P)\mid v\in b\}\) denotes the set of updates induced by \(b\).
Moreover, for a set \(B\) of blocks, \(U(B)=\bigcup_{b\in B}U(b)\) denotes the set of updates induced by \(B\).
#+end_notation

The following lemma shows that for every block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\), every flow pair \(P\), every edge \(e\in E(P^o\cup P^u)\), and every \(i\in[\ell]\), \(\alpha_P(e,B_i)=\mathrm{active}\) iff \(e\) is on the transient (\(s,t\))-path for \(P\) after updating all blocks in \(B_i\).

#+name: lem:alpha-block-eq-active-iff
#+begin_lem
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence, \(P\) be a flow pair, \(e\in E(P^o\cup P^u)\), and \(i\in[\ell]\).
Then \(\alpha_P(e,B_i)=\mathrm{active}\) iff \(e\in E(T_{P,U(B_i)})\).
#+end_lem

#+name: defn:feasible-block-sequence
#+begin_defn
A block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) is /feasible/ if for every edge \(e\) and every index \(i\in[\ell]\),
#+name: eqn:capacity-constraint-blocks
\begin{equation}
c(e)\geq\sum_{P\in\mathcal{P}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P,
\end{equation}
where we define \(\mathscr{B}_0\) to be the empty set.
#+end_defn

#+name: remark:capacity-constraint-blocks-demand-1
#+begin_remark
Let \(G\) be an update flow network with unit demand, that is, \(d_P=1\) for every flow pair \(P\), and let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence.
Then, for every edge \(e\) and every index \(i\in[\ell]\), capacity constraint [[eqn:capacity-constraint-blocks]] simplifies to:
\begin{align*}
c(e)
&\geq\sum_{P\in\mathcal{P}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P\\
&=\sum_{P\in\mathcal{P}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}1\\
&=\lvert\{P\in\mathcal{P}\mid\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}\}\rvert.
\end{align*}
#+end_remark

#+name: lem:update-flow-network-feasible-if
#+begin_lem
Let \(G\) be a not necessarily feasible update flow network and \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence. Then:

1. @@latex:\label{itm:lem-update-flow-network-feasible-if-1}@@
   The old flow network is feasible if capacity constraint [[eqn:capacity-constraint-blocks]] is satisfied for every edge and \(i=1\).

2. @@latex:\label{itm:lem-update-flow-network-feasible-if-2}@@
   The updated flow network is feasible if capacity constraint [[eqn:capacity-constraint-blocks]] is satisfied for every edge and \(i=\ell\).
#+end_lem

#+begin_proof
Let \(G\) be a not necessarily feasible update flow network and \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence.
Moreover, let \(e\) be an edge.

#+latex: \paragraph{\ref{itm:lem-update-flow-network-feasible-if-1}.}
Suppose capacity constraint [[eqn:capacity-constraint-blocks]]  is satisfied for \(e\) and \(i=1\).
Then, since \(\mathscr{B}_0=\emptyset\), and by definitions of \(B_i\) and \(\alpha_P\):
\begin{align*}
c(e)
&\geq\sum_{P\in\mathcal{P}:\alpha_P(e,B_0)=\mathrm{active}\text{ or }\alpha_P(e,B_1)=\mathrm{active}}d_P\\
&\geq\sum_{P\in\mathcal{P}:\alpha_P(e,B_0)=\mathrm{active}}d_P\\
&=\sum_{P\in\mathcal{P}:e\in E(P^o)}d_P.
\end{align*}
#+latex: \paragraph{\ref{itm:lem-update-flow-network-feasible-if-2}.}
Suppose capacity constraint [[eqn:capacity-constraint-blocks]]  is satisfied for \(e\) and \(i=\ell\).
Then, since \(\mathcal{B}\) partitions the set of blocks, and by definitions of \(B_i\) and \(\alpha_P\):
\begin{align*}
c(e)
&\geq\sum_{P\in\mathcal{P}:\alpha_P(e,B_{\ell-1})=\mathrm{active}\text{ or }\alpha_P(e,B_{\ell})=\mathrm{active}}d_P\\
&\geq\sum_{P\in\mathcal{P}:\alpha_P(e,B_{\ell})=\mathrm{active}}d_P\\
&=\sum_{P\in\mathcal{P}:e\in E(P^u)}d_P.
\end{align*}
#+end_proof

#+name: corollary:block-sequence-iff-update-sequence
#+begin_corollary
There is a feasible block sequence iff there is a feasible update sequence.
#+end_corollary

** Block Permutations

#+name: notation:permutation
#+begin_notation
For a set \(S\) and a permutation \(\pi=(x_1,\dots,x_{\ell})\) of \(S\),

1. @@latex:\label{itm:notation-permutation-1}@@
   \(S(\pi)\) denotes the set \(S\) of which \(\pi\) is a permutation;

2. @@latex:\label{itm:notation-permutation-2}@@
   \(\lvert\pi\rvert\) denotes the number \(\ell\) of elements of \(\pi\);

3. @@latex:\label{itm:notation-permutation-3}@@
   for an index \(i\in[\ell]\), \(\pi_i\) denotes the \(i\)-th element \(x_i\) of \(\pi\); and

4. @@latex:\label{itm:notation-permutation-4}@@
   for an element \(x\in S\), \(\pi(x)\) denotes the index \(i\) such that \(\pi_i=x\).
#+end_notation

#+name: notation:core
#+begin_notation
For two permutations \(\pi_1,\pi_2\), \(\mathrm{core}(\pi_1,\pi_2)=S(\pi_1)\cap S(\pi_2)\) denotes the /core/ of \(\pi_1\) and \(\pi_2\).
#+end_notation

#+name: defn:restriction-extension
#+begin_defn
Let \(\pi\) be a permutation and \(\pi'\) be a subsequence of \(\pi\). Then:

1. \(\pi\) is an /extension/ of \(\pi'\) to \(S(\pi)\supseteq S(\pi')\); and

2. \(\pi'\) is the /restriction/ of \(\pi\) to \(S(\pi')\subseteq S(\pi)\).
#+end_defn

- [ ] Should we define subsequence?
- [ ] Remark something about empty permutations.

#+name: defn:consistent-permutations
#+begin_defn
Two permutations \(\pi_1,\pi_2\) are /consistent/ if the restrictions of \(\pi_1\) and \(\pi_2\) to \(\mathrm{core}(\pi_1,\pi_2)\) are equal.
#+end_defn

#+name: lem:three-permutations
#+begin_lem
Let \(\pi_1,\pi_2,\pi_3\) be three permutations such that \(S(\pi_1)\subseteq S(\pi_2)\subseteq S(\pi_3)\).
Then:

1. @@latex:\label{itm:lem-three-permutations-1}@@
   If \(\pi_3\) is an extension of \(\pi_2\) and \(\pi_2\) is an extension of \(\pi_1\), then \(\pi_3\) is an extension of \(\pi_2\).

2. @@latex:\label{itm:lem-three-permutations-2}@@
   If \(\pi_3\) is an extension of both \(\pi_1\) and \(\pi_2\), then \(\pi_2\) is an extension of \(\pi_1\).
#+end_lem

#+begin_proof
Let \(\pi_1,\pi_2,\pi_3\) be three permutations such that \(S(\pi_1)\subseteq S(\pi_2)\subseteq S(\pi_3)\).

#+latex: \paragraph{\ref{itm:lem-three-permutations-1}.}

#+latex: \paragraph{\ref{itm:lem-three-permutations-2}.}
#+end_proof

#+name: defn:union
#+begin_defn
Let \(\pi_1,\pi_2\) be two consistent permutations.
A permutation \(\pi\) is a /union/ of \(\pi_1\) and \(\pi_2\) if \(\pi\) is an extension of both \(\pi_1\) and \(\pi_2\) to \(S(\pi_1)\cup S(\pi_2)\).
#+end_defn

#+name: defn:congestion-free-permutation
#+begin_defn
Let \(X\subseteq E(G)\) be a set of edges.
A permutation \(\pi=(b_1,\dots,b_{\ell})\) of blocks is /congestion free/ w.r.t. \(X\) if for every edge \(e\in X\) and every index \(i\in[\ell]\),
#+name: eqn:capacity-constraint-permutations
\begin{equation}
c(e)\geq \sum_{P\in\mathcal{P}:\alpha_P(e,B_i)=\mathrm{active}}d_P,
\end{equation}
where \(B_i=\bigcup_{j\leq i}\{b_i\}\).
#+end_defn

- [ ] Remark why we may overload notation \(B_i\).

#+name: lem:
#+begin_lem
Let \(X\subseteq E(G)\) be a set of edges and \(\pi=(b_1,\dots,b_{\ell})\) be a permutation of blocks.
Then \(\pi\) is congestion free w.r.t. \(X\) iff the block sequence \(\mathcal{B}=(\{b_1\},\dots,\{b_{\ell}\})\) induced by \(\pi\) is feasible w.r.t. \(X\).
#+end_lem

- [ ] The block sequence induced by \(\pi\) is not defined unless \(S(\pi)=B(G)\).

- [ ] Feasible w.r.t. \(X\) is not defined unless \(X=E(G)\).

#+begin_proof
Let \(X\subseteq E(G)\) be a set of edges, \(\pi=(b_1,\dots,b_{\ell})\) be a permutation, and \(e\in X\) be an edge.

#+latex: \paragraph{Only-if part.}
Let \(i\in[\ell]\).
If capacity constraint [[eqn:capacity-constraint-blocks]] is satisfied for the block sequence \(\mathcal{B}=(\{b_1\},\dots,\{b_{\ell}\})\) induced by \(\pi\), \(e\), and \(i\), then capacity constraint [[eqn:capacity-constraint-permutations]] is satisfied for \(\pi\), \(e\), and \(i\):
\[
\sum_{P\in\mathcal{P}:\alpha_P(e,B_i)=\mathrm{active}}d_P\leq\sum_{P\in\mathcal{P}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P\leq c(e)
\]

#+latex: \paragraph{If part.}
We show the contrapositive.
Suppose capacity contraint [[eqn:capacity-constraint-blocks]] is violated for some \(i\in[\ell]\).
We show that capacity constraint [[eqn:capacity-constraint-permutations]] is violated for \(i\) or \(i-1\).
Notice that if \(i=1\), then the latter contradicts the feasibility of update flow network \(G\).

Since block \(b_i\) is the only block updated in round \(i\), we have that for every block \(b\neq b_i\), \(b\in B_i\) iff \(b\in B_{i-1}\).
Hence for every flow pair \(P\in\mathcal{P}\setminus\{P(b_i)\}\), we have \(\alpha_P(e,B_i)=\mathrm{active}\) iff \(\alpha_P(e,B_{i-1})=\mathrm{active}\).
For flow pair \(P(b_i)\), we consider the cases \(\alpha_{P(b_i)}(e,B_i)=\mathrm{active}\) and \(\alpha_{P(b_i)}(e,B_{i-1})=\mathrm{active}\) separately.
(Note that if neither \(\alpha_{P(b_i)}(e,B_i)=\mathrm{active}\) nor \(\alpha_{P(b_i)}(e,B_{i-1})=\mathrm{active}\), then demand \(d_{P(b_i)}\) contributes to neither sum.)

If \(\alpha_{P(b_i)}(e,B_i)=\mathrm{active}\), then capacity constraint [[eqn:capacity-constraint-permutations]] is violated for \(i\):
\begin{align*}
\sum_{P\in\mathcal{P}:\alpha_P(e,B_i)=\mathrm{active}}d_P&=\\
\sum_{P\in\mathcal{P}\setminus\{P(b_i)\}:\alpha_P(e,B_i)=\mathrm{active}}d_P+\sum_{P\in\{P(b_i)\}:\alpha_P(e,B_i)=\mathrm{active}}d_P&=\\
\sum_{P\in\mathcal{P}\setminus\{P(b_i)\}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P&\\
+\sum_{P\in\{P(b_i)\}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P&=\\
\sum_{P\in\mathcal{P}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P&>
c(e).
\end{align*}

If \(\alpha_{P(b_i)}(e,B_{i-1})=\mathrm{active}\), then capacity constraint [[eqn:capacity-constraint-permutations]] is violated for \(i-1\):
\begin{align*}
\sum_{P\in\mathcal{P}:\alpha_P(e,B_{i-1})=\mathrm{active}}d_P&=\\
\sum_{P\in\mathcal{P}\setminus\{P(b_i)\}:\alpha_P(e,B_{i-1})=\mathrm{active}}d_P+\sum_{P\in\{P(b_i)\}:\alpha_P(e,B_{i-1})=\mathrm{active}}d_P&=\\
\sum_{P\in\mathcal{P}\setminus\{P(b_i)\}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P&\\
+\sum_{P\in\{P(b_i)\}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P&=\\
\sum_{P\in\mathcal{P}:\alpha_P(e,B_{i-1})=\mathrm{active}\text{ or }\alpha_P(e,B_i)=\mathrm{active}}d_P&>
c(e).
\end{align*}
#+end_proof

#+begin_defn
Let \(X\subseteq V(G)\) be a set of vertices.
A permutation \(\pi\) is:

1. an \(X\)-/permutation/ if it is a permutation of the blocks \(\bigcup_{P\in\mathcal{P},v\in X}\{b(v,P)\}\) induced by \(X\); and

2. \(X\)-/feasible/ if it is an \(X\)-permutation and congestion free w.r.t. \(E(X)\).
#+end_defn

- [ ] I think we need to be careful here whether \(E(X)\) comprises directed or undirected edges.

#+begin_defn
Let \(X\subseteq V(G)\) be a set of vertices and \(\pi,\pi'\) be two permutations.
Then:

1. \(\pi\) is an \(X\)-/extension/ of \(\pi'\) if \(\pi\) is an extension of \(\pi'\) to \(X\); and

2. \(\pi'\) and the \(X\)-/restriction/ of \(\pi\) if \(\pi'\) is the extension of \(\pi\) to \(X\).
#+end_defn

#+name: lem:three-permutations-2
#+begin_lem
Let \(X,Y,Z\subseteq V(G)\) be three sets of vertices such that \(X\subseteq Y\subseteq Z\).
Moreover, let \(\pi_X\) be an \(X\)-permutation, \(\pi_Y\) be a \(Y\)-permutation, and \(\pi_Z\) be a \(Z\)-permutation.
Then:

1. @@latex:\label{itm:lem-three-permutations-2-1}@@
   If \(\pi_Z\) is an extension of \(\pi_Y\) and \(\pi_Y\) is an extension of \(\pi_X\), then \(\pi_Z\) is an extension of \(\pi_X\).

2. @@latex:\label{itm:lem-three-permutations-2-2}@@
   If \(\pi_Z\) is an extension of both \(\pi_X\) and \(\pi_Y\), then \(\pi_Y\) is an extension of \(\pi_X\).
#+end_lem

#+begin_proof
The lemma follows immediately from Lemma [[lem:three-permutations]] and the fact that if \(X\subseteq Y\), then \(\bigcup_{P\in\mathcal{P},v\in X}\{b(v,P)\}\subseteq\bigcup_{P\in\mathcal{P},v\in Y}\{b(v,P)\}\).
#+end_proof

* \(\textbf{NP}\)-Hardness for \(k=3\)

The goal of this section is to prove the following theorem.

#+name: thm:np-hardness-k-eq-3
#+begin_thm
The \(k\)-network flow update problem is \(\textbf{NP}\)-hard for \(k=3\).
#+end_thm

We will prove this theorem in two steps.
First, we will prove the following theorem.

#+name: thm:np-hardness-special-case
#+begin_thm
The \(k\)-network flow update problem, where every edge is used by at most three flow pairs, is \(\textbf{NP}\)-hard for \(k=10\).
#+end_thm

Then, we will (repeatedly) apply the following lemma to the flow update network we will have constructed in the proof of Theorem [[thm:np-hardness-special-case]] to reduce the number of flow pairs from \(10\) to \(3\).

#+name: lem:merging-flow-pairs
#+attr_latex: :options [Merging Lemma]
#+begin_lem
Let \(G\) be an update flow network with \(k\geq 2\) flow pairs, and let \(F,F'\) be two flow pairs such that

1. @@latex:\label{itm:lem-merging-flow-pairs-property-1}@@
   \(d_F=d_{F'}\),

2. @@latex:\label{itm:lem-merging-flow-pairs-property-2}@@
   \(F\) and \(F'\) have no common vertices other than \(s,t\), that is, \(V(F^o\cup F^u)\cap V(F'^o\cup F'^u)=\{s,t\}\), and

3. @@latex:\label{itm:lem-merging-flow-pairs-property-3}@@
   there are vertices \(v_F,v_{F'}\) such that

   1) @@latex:\label{itm:lem-merging-flow-pairs-property-3-1}@@
      there is no edge from \(v_F\) to \(v_{F'}\), that is, \((v_F,v_{F'})\notin E\),

   2) @@latex:\label{itm:lem-merging-flow-pairs-property-3-2}@@
      \((v_F,t)\) (\((s,v_{F'})\)) is the last (first) edge on both \(F^o\) and \(F^u\) (\(F'^o\) and \(F'^u\)), that is, \((v_F,t)\in E(F^o\cap F^u)\) (\((s,v_{F'})\in E(F'^o\cap F'^u)\)), and

   3) @@latex:\label{itm:lem-merging-flow-pairs-property-3-3}@@
      the capacity constraint for \((v_F,t)\) (\((s,v_{F'})\)) is trivially satisfied, that is,
      \[
      c(e)\geq\sum_{P\in\mathcal{P}:e\in E(P^o\cup P^u)}d_P
      \]
      for \(e=(v_F,t)\) (\(e=(s,v_{F'})\)).


Then there is an update flow network \(\tilde{G}\) with \(k-1\) flow pairs such that (\(\lvert\tilde{G}\rvert=O(\lvert G\rvert)\) and) there is a feasible block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) for \(G\) iff there is a feasible block sequence \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) for \(\tilde{G}\).
#+end_lem

#+begin_remark
I'm confident we don't need property \ref{itm:lem-merging-flow-pairs-property-3}, but it significantly simplifies the proof.
#+end_remark

** \(\textbf{NP}\)-Hardness for the Special Case

The proof of Theorem [[thm:np-hardness-special-case]] is via reduction from \(\textsf{4-SAT}\) and is based on the \(\textbf{NP}\)-hardness proof for \(k=6\) in [cite:@amiri2019polynomialtime].

Let \(C\) be a 4CNF formula with \(n\) variables \(x_1,\dots,x_n\) and \(m\) clauses \(C_1,\dots,C_m\).
W.l.o.g. every variable occurs both positively and negatively (otherwise, if a variable \(x_j\) occurs only positively (negatively), we can assign \(1\) (\(0\)) to \(x_j\) and remove all clauses containing literal \(x_j\) (\(\bar{x}_j\))).
We construct the corresponding update flow network \(G\) as follows.

*** The Reduction

We will need to transform a solution for formula \(C\), that is, a satisfying assignment, into a solution for update flow network \(G\), that is, a feasible block sequence, and vice versa.
We will do this by mapping the choice of assigning either \(1\) or \(0\) to variable \(x_j\) to the choice of updating a corresponding block, say \(b^j\), after a dedicated reference block \(b\) or not, and vice versa.
For this purpose, we construct a /variable gadget/ \(X^j\) for every variable \(x_j\) such that, in particular, block \(b^j\) is specific to \(X^j\), whereas reference block \(b\) is not.
Moreover, in particular to guarantee that an assignment obtained from a feasible block sequence as indicated above indeed satisfies every clause, we additionally construct a /clause gadget/ for every clause.
We first describe the variable gadgets.

- [ ] Mention that all flow pairs have unit demand.

#+latex: \paragraph{Variable gadgets.}
For every variable \(x_j\), we construct the corresponding variable gadget \(X^j\) as follows (see Figure [[fig:variable-gadget]]).
As indicated above, the idea is that \(X^j\) contains a block \(b^j\) such that:

#+attr_latex: :options [label=(V\arabic*)]
#+begin_enumerate
\item\label{itm:v1}
Variable \(x_j\) is assigned \(1\) iff block \(b^j\) is updated after reference block \(b\).
#+end_enumerate

Therefore, we introduce a /variable vertex/ \(x^j\) which is used by three flow pairs \(X,\bar{X},B\) such that \(b^j=b(x^j,\bar{X})\) and \(b=b(x^j,B)\).
Intuitively, updating flow pair \(X\) (\(\bar{X}\)) before \(B\) for \(x^j\) corresponds to assigning \(1\) (\(0\)) to variable \(x_j\).
More precisely, the idea is to guarantee the following:

#+attr_latex: :options [label=(V\arabic*),start=2]
#+begin_enumerate
\item\label{itm:v2}
If block \(b(x^j,X)\) is updated before \(b(x^j,B)\), then variable \(x_j\) is assigned \(1\).
\item\label{itm:v3}
If \(b(x^j,\bar{X})\) is updated before \(b(x^j,B)\), then \(x_j\) is assigned \(0\).
\item\label{itm:v4}
Not both \(b(x^j,X)\) and \(b(x^j,\bar{X})\) can be updated before \(b(x^j,B)\).
#+end_enumerate

Notice that \ref{itm:v1} and \ref{itm:v4} imply both \ref{itm:v2} and \ref{itm:v3}.
To guarantee \ref{itm:v4}, we introduce a vertex \(y^j\) and add an edge \((x^j,y^j)\) with capacity \(2\) to flows \(X^u,\bar{X}^u,B^o\).

Moreover, we introduce auxiliary vertices \(x_0^j,y_0^j,x_1^j,y_1^j\) and add edge \((x_0^j,y_0^j)\) with capacity \(1\) to flow \(\bar{X}^o\) and \((x_1^j,y_1^j)\) with capacity \(1\) to \(X^o\).
These will be used to connect variable with clause gadgets.
More precisely, \(x_0^j\) (\(x_1^j\)) will be connected to clause gadgets corresponding to clauses in which variable \(x_j\) occurs negatively (positively).

As mentioned above, block \(b^j\) should be completely contained in variable gadget \(X^j\).
Therefore, we add edges \((x^j,x_0^j),(y_0^j,y^j)\) with capacity \(10\) to flow \(\bar{X}^o\) and \((x^j,x_1^j),(y_1^j,y^j)\) with capacity \(10\) to \(X^o\).

- [ ] Either use capacity \(\infty\) or argue why we use capacity \(10\).

#+caption: Variable gadget \(X^j\)
#+name: fig:variable-gadget
[[file:../assets/Screen Shot 2023-02-14 at 15.06.35.png]]

#+latex: \paragraph{Clause gadgets.}
Let \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\) be a clause.
We construct the corresponding clause gadget \(C^i\) as follows (see Figure [[fig:clause-gadget-3]]).
The idea is to model the syntax tree for \(C_i\) depicted in Figure [[fig:syntax-tree]].

#+caption: A syntax tree for clause \((l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\)
#+name: fig:syntax-tree
[[file:../assets/Screen Shot 2023-02-14 at 15.05.37.png]]

For the root operator node, we introduce a /clause vertex/ \(u^i\) which is used by three flow pairs \(L,R,B\) such that block \(b(u^i,B)\) equals the reference block \(b\).
The idea is to guarantee the following:

#+attr_latex: :options [label=(C\arabic*)]
#+begin_enumerate
\item\label{itm:c1}
Clause \(C_i\) is satisfied iff block \(b(u^i,L)\) is updated before \(b\) or \(b(u^i,R)\) is updated before \(b\).
#+end_enumerate

Intuitively, if \(b(u^i,L)\) (\(b(u^i,R)\)) is updated before \(b\), then the \(\textbf{L}\)eft half \((l_{i_1}\vee l_{i_2})\) (\(\textbf{R}\)ight half \((l_{i_3}\vee l_{i_4})\)) of \(C_i\) is satisfied.
Similarly, for the intermediate operator nodes of the syntax tree, we introduce clause vertices \(u_L^i,u_R^i\), where \(u_L^i\) corresponds to the left half \((l_{i_1}\vee l_{i_2})\) of \(C_i\) and \(u_R^i\) corresponds to the right half \((l_{i_3}\vee l_{i_4})\).
Both vertices are used by flow pairs \(\tilde{L},\tilde{R},\tilde{B}\) such that:

#+attr_latex: :options [label=(C\arabic*),start=2]
#+begin_enumerate
\item\label{itm:c2}
Suppose block \(b(u^i,L)\) is updated before \(b\).
Then clause \((l_{i_1}\vee l_{i_2})\) is satisfied if \(b(u_L^i,\tilde{L})\) is updated before \(b(u_L^i,\tilde{B})\) or \(b(u_L^i,\tilde{R})\) is updated before \(b(u_L^i,\tilde{B})\).
\item\label{itm:c3}
Suppose block \(b(u^i,R)\) is updated before \(b\).
Then clause \((l_{i_3}\vee l_{i_4})\) is satisfied if \(b(u_R^i,\tilde{L})\) is updated before \(b(u_R^i,\tilde{B})\) or \(b(u_R^i,\tilde{R})\) is updated before \(b(u_R^i,\tilde{B})\).
#+end_enumerate

Again, intuitively, if \(b(u_L^i,\tilde{L})\) (\(b(u_L^i,\tilde{R})\)) is updated before \(b(u_L^i,\tilde{B})\), then the left half \(l_{i_1}\) (right half \(l_{i_2}\)) of \((l_{i_1}\vee l_{i_2})\) is satisfied, and analogously for \(u_R^i\).

Moreover, for the operand nodes of the syntax tree, we introduce /literal vertices/ \(u_1^i,u_2^i,u_3^i,u_4^i\).
Finally, for every branch from a parent node to its left (right) child node, we add an edge to either \(L^u\) (\(R^u\)) (if the parent node is \(u^i\)) or \(\tilde{L}^u\) (\(\tilde{R}^u\)) (if the parent node is \(u_L^i\) or \(u_R^i\)).
See Figure [[fig:clause-gadget-1]] for an illustration.

#+caption: Clause gadget \(C^i\)
#+name: fig:clause-gadget-1
[[file:../assets/Screen Shot 2023-05-27 at 14.31.00.png]]

To guarantee \ref{itm:c1}, we introduce a vertex \(v^i\) and add an edge \((u^i,v^i)\) with capacity \(2\) to flows \(L^o,R^o,B^u\).
Similarly, to guarantee \ref{itm:c2} and \ref{itm:c3}, we introduce vertices \(v_L^i,v_R^i\) and add edges \((u_L^i,v_L^i),(u_R^i,v_R^i)\) with capacity \(2\) to flows \(\tilde{L}^o,\tilde{R}^o,\tilde{B}^u\).
See Figure [[fig:clause-gadget-2]] for an illustration.

#+caption: Clause gadget \(C^i\)
#+name: fig:clause-gadget-2
[[file:../assets/Screen Shot 2023-05-27 at 14.31.31.png]]

Moreover, we introduce vertices \(v_1^i,v_2^i,v_3^i,v_4^i\) and add edges \((u_1^i,v_1^i),(u_3^i,v_3^i)\) with capacity \(1\) to flow \(\tilde{L}^u\) and \((u_2^i,v_2^i),(u_4^i,v_4^i)\) with capacity \(1\) to \(\tilde{R}^u\).
These will be used to connect variable with clause gadgets.

Finally, we introduce auxiliary vertices \(\tilde{u}_L^i,\tilde{v}_L^i,\tilde{u}_R^i,\tilde{v}_R^i\) and add edge \((\tilde{u}_L^i,\tilde{v}_L^i)\) with capacity \(1\) to flows \(L^u,\tilde{B}^o\) and \((\tilde{u}_R^i,\tilde{v}_R^i)\) with capacity \(1\) to \(R^u,\tilde{B}^o\).
We remark that these vertices, as well as flow pair \(\tilde{B}\), are not necessary for this proof.
Instead, we could directly connect clause vertices \(u^i,u_L^i\) via flow pair \(L\) and \(u^i,u_R^i\) via \(R\).
They are necessary, however, for the proof of Theorem [[thm:np-hardness-k-eq-3]].

Since we want to guarantee \ref{itm:c1}, \ref{itm:c2}, and \ref{itm:c3} for each clause independently, blocks \(b(u^i,L),b(u^i,R),b(u_L^i,\tilde{L}),b(u_L^i,\tilde{R}),b(u_R^i,\tilde{L}),b(u_R^i,\tilde{R})\) should be completely contained in clause gadget \(C^i\).
Moreover, since we want to guarantee \ref{itm:c2} and \ref{itm:c3} independently, blocks \(b(u_L^i,\tilde{L}),b(u_R^i,\tilde{L})\), \(b(u_L^i,\tilde{R}),b(u_R^i,\tilde{R})\), and \(b(u_L^i,\tilde{B}),b(u_R^i,\tilde{B})\) should be distinct.
Therefore, we add the following edges, each with capacity \(10\):

- \((u^i,\tilde{u}_L^i),(\tilde{v}_L^i,v^i)\) to \(L^u\)
- \((u^i,\tilde{u}_R^i),(\tilde{v}_R^i,v^i)\) to \(R^u\)
- \((u_L^i,u_1^i),(v_1^i,v_L^i),(u_R^i,u_3^i),(v_3^i,v_R^i)\) to \(\tilde{L}^u\)
- \((u_L^i,u_2^i),(v_2^i,v_L^i),(u_R^i,u_4^i),(v_4^i,v_R^i)\) to \(\tilde{R}^u\)
- \((\tilde{u}_L^i,u_L^i),(v_L^i,\tilde{v}_L^i),(\tilde{u}_R^i,u_R^i),(v_R^i,\tilde{v}_R^i)\) to \(\tilde{B}^u\)


Finally, to obtain \((s,t)\)-paths in the end, we add the following edges, each with capacity \(10\):

- \((v_L^i,u_R^i)\) to \(\tilde{L}^o,\tilde{L}^u,\tilde{R}^o,\tilde{R}^u\)
- \((\tilde{v}_L^i,\tilde{u}_R^i)\) to \(\tilde{B}^o,\tilde{B}^u\)

#+caption: Clause gadget \(C^i\)
#+name: fig:clause-gadget-3
[[file:../assets/Screen Shot 2023-02-14 at 15.07.03.png]]

- [ ] Merge clause gadget figures.

#+latex: \paragraph{Connecting variable with clause gadgets.}
For every \(j\in[n]\) and every \(i\in[m]\), we connect variable gadget \(X^j\) to clause gadget \(C^i\) if variable \(x_j\) occurs in clause \(C_i\).
More precisely, we introduce two flow pairs \(B_0,B_1\) such that \(B_0\) (\(B_1\)) connects vertex \(x_0^j\) (\(x_1^j\)) to all literal vertices corresponding to literal \(\bar{x}_j\) (\(x_j\)).
More formally, for every \(j\in[n]\), let \(P_j=\{p_1^j,\dots,p_{\ell_j}^j\}\) denote the set of indices of the clauses containing literal \(x_j\) and \(\bar{P}_j=\{\bar{p}_1^j,\dots,\bar{p}_{\ell'_j}^j\}\) denote the set of indices of the clauses containing literal \(\bar{x}_j\).
Moreover, for every \(j\in[n]\) and every \(i\in[m]\), let \(\pi(i,j)\) denote the position of literal \(x_j\) in clause \(C_i\) and \(\bar{\pi}(i,j)\) denote the position of literal \(\bar{x}_j\) in \(C_i\).
For every \(j\in[n]\), we add the following edges:

- \((x_0^j,u_{\bar{\pi}(\bar{p}_1^j,j)}^{\bar{p}_1^j})\) with capacity \(10\), \((u_{\bar{\pi}(\bar{p}_{\ell}^j,j)}^{\bar{p}_{\ell}^j},v_{\bar{\pi}(\bar{p}_{\ell}^j,j)}^{\bar{p}_{\ell}^j})\) for every \(\ell\in[\ell'_j]\), \((v_{\bar{\pi}(\bar{p}_{\ell}^j,j)}^{\bar{p}_{\ell}^j},u_{\bar{\pi}(\bar{p}_{\ell+1}^j,j)}^{\bar{p}_{\ell+1}^j})\) with capacity \(10\) for every \(\ell\in[\ell'_j-1]\), and \((v_{\bar{\pi}(\bar{p}_{\ell'_j}^j,j)}^{\bar{p}_{\ell'_j}^j},y_0^j)\) with capacity \(10\) to \(B_0^o\)
- \((x_1^j,u_{\pi(p_1^j,j)}^{p_1^j})\) with capacity \(10\), \((u_{\pi(p_{\ell}^j,j)}^{p_{\ell}^j},v_{\pi(p_{\ell}^j,j)}^{p_{\ell}^j})\) for every \(\ell\in[\ell_j]\), \((v_{\pi(p_{\ell}^j,j)}^{p_{\ell}^j},u_{\pi(p_{\ell+1}^j,j)}^{p_{\ell+1}^j})\) with capacity \(10\) for every \(\ell\in[\ell_j-1]\), and \((v_{\pi(p_{\ell_j}^j,j)}^{p_{\ell_j}^j},y_1^j)\) with capacity \(10\) to \(B_1^o\)

#+latex: \paragraph{Putting everything together.}
We introduce vertices \(s,t\) and create (\(s,t\))-paths for all flows by adding the following edges:

- \((s,u^1),(v^m,t)\) to \(L^o,L^u,R^o,R^u\)
- \((v^i,u^{i+1})\) for every \(i\in[m-1]\) to \(L^o,L^u,R^o,R^u,B^u\)
- \((s,u_L^1)\), \((v_R^i,u_L^{i+1})\) for every \(i\in[m-1]\), and \((v_R^m,t)\) to \(\tilde{L}^o,\tilde{L}^u,\tilde{R}^o,\tilde{R}^u\)
- \((s,\tilde{u}_L^1)\), \((\tilde{v}_R^i,\tilde{u}_L^{i+1})\) for every \(i\in[m-1]\), and \((\tilde{v}_R^m,t)\) to \(\tilde{B}^o,\tilde{B}^u\)
- \((s,x^1),(y^n,t)\) to \(X^o,X^u,\bar{X}^o,\bar{X}^u,B^o,B^u\)
- \((y^j,x^{j+1})\) for every \(j\in[n-1]\) to \(X^o,X^u,\bar{X}^o,\bar{X}^u,B^o\)
- \((x^1,u^1),(v^m,y^n)\) to \(B^u\)
- \((s,x_0^1)\), \((y_0^j,x_0^{j+1})\) for every \(j\in[n-1]\), and \((y_0^n,t)\) to \(B_0^o,B_0^u\)
- \((s,x_1^1)\), \((y_1^j,x_1^{j+1})\) for every \(j\in[n-1]\), and \((y_1^n,t)\) to \(B_1^o,B_1^u\)

See Figure [[fig:update-flow-network]] for the complete update flow network and Table [[tab:s-t-flows]] for all (\(s,t\))-flows.

#+caption: The update flow network
#+name: fig:update-flow-network
[[file:../assets/Screen Shot 2023-02-14 at 15.08.01.png]]

#+caption: All (\(s,t\))-flows
#+name: tab:s-t-flows
| Flow            | (\(s,t\))-path                                                                                                                                                                         |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(\bar{X}^o\)   | \(s,x^1,x_0^1,y_0^1,y^1,x^2,\dots,y^n,t\)                                                                                                                                              |
| \(\bar{X}^u\)   | \(s,x^1,y^1,x^2,\dots,y^n,t\)                                                                                                                                                          |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(L^o\)         | \(s,u^1,v^1,u^2,\dots,v^m,t\)                                                                                                                                                          |
| \(L^u\)         | \(s,u^1,\tilde{u}_L^1,\tilde{v}_L^1,v^1,u^2,\dots,v^m,t\)                                                                                                                      |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(\tilde{L}^o\) | \(s,u_L^1,v_L^1,u_R^1,v_R^1,u_L^2,\dots,v_R^m,t\)                                                                                                              |
| \(\tilde{L}^u\) | \(s,u_L^1,u_1^1,v_1^1,v_L^1,u_R^1,u_3^1,v_3^1,v_R^1,u_L^2,\dots,v_R^m,t\)                                                                                      |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(X^o\)         | \(s,x^1,x_1^1,y_1^1,y^1,x^2,\dots,y^n,t\)                                                                                                                                              |
| \(X^u\)         | \(s,x^1,y^1,x^2,\dots,y^n,t\)                                                                                                                                                          |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(R^o\)         | \(s,u^1,v^1,u^2,\dots,v^m,t\)                                                                                                                                                          |
| \(R^u\)         | \(s,u^1,\tilde{u}_R^1,\tilde{v}_R^1,v^1,u^2,\dots,v^m,t\)                                                                                                                      |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(\tilde{R}^o\) | \(s,u_L^1,v_L^1,u_R^1,v_R^1,u_L^2,\dots,v_R^m,t\)                                                                                                              |
| \(\tilde{R}^u\) | \(s,u_L^1,u_2^1,v_2^1,v_L^1,u_R^1,u_4^1,v_4^1,v_R^1,u_L^2,\dots,v_R^m,t\)                                                                                      |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(B^o\)         | \(s,x^1,y^1,x^2,\dots,y^n,t\)                                                                                                                                                          |
| \(B^u\)         | \(s,x^1,u^1,v^1,u^2,\dots,v^m,y^n,t\)                                                                                                                                                  |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(\tilde{B}^o\) | \(s,\tilde{u}_L^1,\tilde{v}_L^1,\tilde{u}_R^1,\tilde{v}_R^1,\tilde{u}_L^2,\dots,\tilde{v}_R^m,t\)                                                              |
| \(\tilde{B}^u\) | \(s,\tilde{u}_L^1,u_L^1,v_L^1,\tilde{v}_L^1,\tilde{u}_R^1,u_R^1,v_R^1,\tilde{v}_R^1,\tilde{u}_L^2,\dots,\tilde{v}_R^m,t^\)                     |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(B_0^o\)       | \(s,x_0^1,u_{\bar{\pi}(\bar{p}_1^1,1)}^{\bar{p}_1^1},v_{\bar{\pi}(\bar{p}_1^1,1)}^{\bar{p}_1^1},u_{\bar{\pi}(\bar{p}_2^1,1)}^{\bar{p}_2^1},\dots,v_{\bar{\pi}(\bar{p}_{l'_1}^1,1)}^{\bar{p}_{l'_1}^1},y_0^1,x_0^2,\dots,y_0^n,t\) |
| \(B_0^u\)       | \(s,x_0^1,y_0^1,x_0^2,\dots,y_0^n,t\)                                                                                                                                                  |
|-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| \(B_1^o\)       | \(s,x_1^1,u_{\pi(p_1^1,1)}^{p_1^1},v_{\pi(p_1^1,1)}^{p_1^1},u_{\pi(p_2^1,1)}^{p_2^1},\dots,v_{\pi(p_{l_1}^1,1)}^{p_{l_1}^1},y_1^1,x_1^2,\dots,y_1^n,t\)                                |
| \(B_1^u\)       | \(s,x_1^1,y_1^1,x_1^2,\dots,y_1^n,t\)                                                                                                                                                  |
|                 |                                                                                                                                                                                        |

Edge capacities are defined as follows.

- We set the capacity to \(2\) for edges \((u^i,v^i),(u_L^i,v_L^i),(u_R^i,v_R^i),(x^j,y^j)\) for every \(i\in[m]\) and every \(j\in[n]\).
- We set the capacity to \(1\) for edges \((u_1^i,v_1^i),(u_2^i,v_2^i),(u_3^i,v_3^i),(u_4^i,v_4^i),(\tilde{u}_L^i,\tilde{v}_L^i),(\tilde{u}_R^i,\tilde{v}_R^i),(x_0^j,y_0^j),(x_1^j,y_1^j)\) for every \(i\in[m]\) and every \(j\in[n]\).
- All remaining edge capacities are set to \(10\), that is, the number of flow pairs, which equals the sum of all demands.

We remark that vertices \(\tilde{u}_L^i,\tilde{v}_L^i,\tilde{u}_R^i,\tilde{v}_R^i\) are not necessary for this proof.
Instead, we could directly connect clause vertices \(u^i,u_L^i\) via flow pair \(L\) and \(u^i,u_R^i\) via \(R\).
Similarly, vertices \(x_0^j,y_0^j,x_1^j,y_1^j\) as well as flow pairs \(B_0,B_1\) are not necessary.
We could instead directly connect variable vertex \(x^j\) to literal vertex, say \(u_1^i\), via \(X\) (\(\bar{X}\)) if \(l_{i_1}=x_j\) (\(l_{i_1}=\bar{x}_j\)).
The vertices and flow pairs are necessary, however, for the proof of Theorem [[thm:np-hardness-k-eq-3]].

Let us quickly verify that \(G\) is a feasible update flow network.

To verify that every flow is indeed an \((s,t)\)-path, see Table [[tab:s-t-flows]].
Recall we assumed every variable \(x_j\) occurs both negatively and positively in formula \(C\).
Hence both \(\bar{P}_j\) and \(P_j\) are non-empty.
Thus both \(B_0^o\) and \(B_1^o\) form \((s,t)\)-paths.

To verify that every flow pair forms a DAG, again consider Table [[tab:s-t-flows]].

Using Lemma [[lem:update-flow-network-feasible-if]], we will show that all capacity constraints are satisfied for both the old flow network and the updated flow network in the if part of the proof of Theorem [[thm:np-hardness-special-case]].

#+caption: All blocks grouped by flow pair
#+name: tab:blocks
| \(P\)         | \(V(P^o\cap P^u)\) ordered w.r.t. \(\leq_{P^o\cup P^u}\)                                                                  | \(B^P(G)\)                                                                                 |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(\bar{X}\)   | \(s,x^1,y^1,x^2,\dots,y^n,t\)                                                                                             | \(\{s,x^1\}\),                                                                             |
|               |                                                                                                                           | \(\{x^j,x_0^j,y_0^j,y^j\},j\in[n]\),                                                       |
|               |                                                                                                                           | \(\{y^j,x^{j+1}\},j\in[n-1]\),                                                             |
|               |                                                                                                                           | \(\{y^n,t\}\)                                                                              |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(L\)         | \(s,u^1,v^1,u^2,\dots,v^m,t\)                                                                                             | \(\{s,u^1\}\),                                                                             |
|               |                                                                                                                           | \(\{u^i,\tilde{u}_L^i,\tilde{v}_L^i,v^i\},i\in[m]\),                               |
|               |                                                                                                                           | \(\{v^i,u^{i+1}\},i\in[m-1]\),                                                             |
|               |                                                                                                                           | \(\{v^m,t\}\)                                                                              |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(\tilde{L}\) | \(s,u_L^1,v_L^1,u_R^1,v_R^1,u_L^2,\dots,v_R^m,t\)                                                 | \(\{s,u_L^1\}\),                                                                       |
|               |                                                                                                                           | \(\{u_L^i,u_1^i,v_1^i,v_L^i\},i\in[m]\),                                           |
|               |                                                                                                                           | \(\{v_L^i,u_R^i\},i\in[m]\),                                                       |
|               |                                                                                                                           | \(\{u_R^i,u_3^i,v_3^i,v_R^i\},i\in[m]\),                                           |
|               |                                                                                                                           | \(\{v_R^i,u_L^{i+1}\},i\in[m-1]\),                                                 |
|               |                                                                                                                           | \(\{v_R^m,t\}\)                                                                        |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(X\)         | \(s,x^1,y^1,x^2,\dots,y^n,t\)                                                                                             | \(\{s,x^1\}\),                                                                             |
|               |                                                                                                                           | \(\{x^j,x_1^j,y_1^j,y^j\},j\in[n]\),                                                       |
|               |                                                                                                                           | \(\{y^j,x^{j+1}\},j\in[n-1]\),                                                             |
|               |                                                                                                                           | \(\{y^n,t\}\)                                                                              |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(R\)         | \(s,u^1,v^1,u^2,\dots,v^m,t\)                                                                                             | \(\{s,u^1\}\),                                                                             |
|               |                                                                                                                           | \(\{u^i,\tilde{u}_R^i,\tilde{v}_R^i,v^i\},i\in[m]\),                               |
|               |                                                                                                                           | \(\{v^i,u^{i+1}\},i\in[m-1]\),                                                             |
|               |                                                                                                                           | \(\{v^m,t\}\)                                                                              |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(\tilde{R}\) | \(s,u_L^1,v_L^1,u_R^1,v_R^1,u_L^2,\dots,v_R^m,t\)                                                 | \(\{s,u_L^1\}\),                                                                       |
|               |                                                                                                                           | \(\{u_L^i,u_2^i,v_2^i,v_L^i\},i\in[m]\),                                           |
|               |                                                                                                                           | \(\{v_L^i,u_R^i\},i\in[m]\),                                                       |
|               |                                                                                                                           | \(\{u_R^i,u_4^i,v_4^i,v_R^i\},i\in[m]\),                                           |
|               |                                                                                                                           | \(\{v_R^i,u_L^{i+1}\},i\in[m-1]\),                                                 |
|               |                                                                                                                           | \(\{v_R^m,t\}\)                                                                        |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(B\)         | \(s,x^1,y^n,t\)                                                                                                           | \(\{s,x^1\}\), \(\{x^j,y^j,u^i,v^i\mid j\in[n],i\in[m]\}\), \(\{y^n,t\}\)                  |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(\tilde{B}\) | \(s,\tilde{u}_L^1,\tilde{v}_L^1,\tilde{u}_R^1,\tilde{v}_R^1,\tilde{u}_L^2,\dots,\tilde{v}_R^m,t\) | \(\{s,\tilde{u}_L^1\}\),                                                               |
|               |                                                                                                                           | \(\{\tilde{u}_L^i,u_L^i,v_L^i,\tilde{v}_L^i\},i\in[m]\),                   |
|               |                                                                                                                           | \(\{\tilde{v}_L^i,\tilde{u}_R^i\},i\in[m]\),                                       |
|               |                                                                                                                           | \(\{\tilde{u}_R^i,u_R^i,v_R^i,\tilde{v}_R^i\},i\in[m]\),                   |
|               |                                                                                                                           | \(\{\tilde{v}_R^i,\tilde{u}_L^{i+1}\},i\in[m-1]\),                                 |
|               |                                                                                                                           | \(\{\tilde{v}_R^m,t\}\)                                                                |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(B_0\)       | \(s,x_0^1,y_0^1,x_0^2,\dots,y_0^n,t\)                                                                                     | \(\{s,x_0^1\}\),                                                                           |
|               |                                                                                                                           | \(\{x_0^j,u_{\bar{\pi}(i,j)}^i},v_{\bar{\pi}(i,j)}^i},y_0^j\mid i\in\bar{P}_j\},j\in[n]\), |
|               |                                                                                                                           | \(\{y_0^n,t\}\)                                                                            |
|---------------+---------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------|
| \(B_1\)       | \(s,x_1^1,y_1^1,x_1^2,\dots,y_1^n,t\)                                                                                     | \(\{s,x_1^1\}\),                                                                           |
|               |                                                                                                                           | \(\{x_1^j,u_{\pi(i,j)}^i},v_{\pi(i,j)}^i},y_1^j\mid i\in P_j\},j\in[n]\),                  |
|               |                                                                                                                           | \(\{y_1^n,t\}\)                                                                            |
|               |                                                                                                                           |                                                                                            |

*** The Proof

Before we prove Theorem [[thm:np-hardness-special-case]], let us show that every feasible block sequence for the update flow network specified in the previous section satisfies the following properties.

#+name: lem:feasible-block-sequence-properties
#+begin_lem
Let \(\mathcal{B}\) be a feasible block sequence for update flow network \(G\).
Then:

1. @@latex:\label{itm:lem-feasible-block-sequence-properties-1}@@
   For every \(i\in[m]\), \(\mathcal{B}(u^i,L)<\mathcal{B}(x^1,B)\) or \(\mathcal{B}(u^i,R)<\mathcal{B}(x^1,B)\).
         
2. @@latex:\label{itm:lem-feasible-block-sequence-properties-2}@@
   For every \(i\in[m]\),

   1) @@latex:\label{itm:lem-feasible-block-sequence-properties-2-1}@@
      \(\mathcal{B}(\tilde{u}_L^i,\tilde{B})<\mathcal{B}(u^i,L)\), and
   
   2) @@latex:\label{itm:lem-feasible-block-sequence-properties-2-2}@@
      \(\mathcal{B}(\tilde{u}_R^i,\tilde{B})<\mathcal{B}(u^i,R)\).

3. @@latex:\label{itm:lem-feasible-block-sequence-properties-3}@@
   For every \(i\in[m]\),

   1) @@latex:\label{itm:lem-feasible-block-sequence-properties-3-1}@@
      \(\mathcal{B}(u_L^i,\tilde{L})<\mathcal{B}(\tilde{u}_L^i,\tilde{B})\) or \(\mathcal{B}(u_L^i,\tilde{R})<\mathcal{B}(\tilde{u}_L^i,\tilde{B})\), and

   2) @@latex:\label{itm:lem-feasible-block-sequence-properties-3-2}@@
      \(\mathcal{B}(u_R^i,\tilde{L})<\mathcal{B}(\tilde{u}_R^i,\tilde{B})\) or \(\mathcal{B}(u_R^i,\tilde{R})<\mathcal{B}(\tilde{u}_R^i,\tilde{B})\).

4. @@latex:\label{itm:lem-feasible-block-sequence-properties-4}@@
   For every \(j\in[n]\), \(\mathcal{B}(x^1,B)<\mathcal{B}(x^j,\bar{X})\) or \(\mathcal{B}(x^1,B)<\mathcal{B}(x^j,X)\).

5. @@latex:\label{itm:lem-feasible-block-sequence-properties-5}@@
   For every \(i\in[m]\) and every \(j\in[n]\),

   1) @@latex:\label{itm:lem-feasible-block-sequence-properties-5-1}@@
      if \(l_{i_1}=\bar{x}_j\), then \(\mathcal{B}(x_0^j,B_0)<\mathcal{B}(u_L^i,\tilde{L})\), and if \(l_{i_1}=x_j\), then \(\mathcal{B}(x_1^j,B_1)<\mathcal{B}(u_L^i,\tilde{L})\),

   2) @@latex:\label{itm:lem-feasible-block-sequence-properties-5-2}@@
      if \(l_{i_2}=\bar{x}_j\), then \(\mathcal{B}(x_0^j,B_0)<\mathcal{B}(u_L^i,\tilde{R})\), and if \(l_{i_2}=x_j\), then \(\mathcal{B}(x_1^j,B_1)<\mathcal{B}(u_L^i,\tilde{R})\),

   3) @@latex:\label{itm:lem-feasible-block-sequence-properties-5-3}@@
      if \(l_{i_3}=\bar{x}_j\), then \(\mathcal{B}(x_0^j,B_0)<\mathcal{B}(u_R^i,\tilde{L})\), and if \(l_{i_3}=x_j\), then \(\mathcal{B}(x_1^j,B_1)<\mathcal{B}(u_R^i,\tilde{L})\),

   4) @@latex:\label{itm:lem-feasible-block-sequence-properties-5-4}@@
      if \(l_{i_4}=\bar{x}_j\), then \(\mathcal{B}(x_0^j,B_0)<\mathcal{B}(u_R^i,\tilde{R})\), and if \(l_{i_4}=x_j\), then \(\mathcal{B}(x_1^j,B_1)<\mathcal{B}(u_R^i,\tilde{R})\).

6. @@latex:\label{itm:lem-feasible-block-sequence-properties-6}@@
   For every \(j\in[n]\),

   1) @@latex:\label{itm:lem-feasible-block-sequence-properties-6-1}@@
      \(\mathcal{B}(x^j,\bar{X})<\mathcal{B}(x_0^j,B_0)\), and

   2) @@latex:\label{itm:lem-feasible-block-sequence-properties-6-2}@@
      \(\mathcal{B}(x^j,X)<\mathcal{B}(x_1^j,B_1)\).
#+end_lem

#+begin_proof
We show every property by contradiction.
More precisely, for every property, we assume it doesn't hold and then obtain an edge and a round such that the corresponding capacity constraint is violated, which contradicts the feasibility of block sequence \(\mathcal{B}\).

Since every flow pair has demand \(1\), we may use [[remark:capacity-constraint-blocks-demand-1]] to argue about capacity constraints.

#+latex: \paragraph{\ref{itm:lem-feasible-block-sequence-properties-1}, \ref{itm:lem-feasible-block-sequence-properties-3}.}
We only show \ref{itm:lem-feasible-block-sequence-properties-1}; the proofs for \ref{itm:lem-feasible-block-sequence-properties-3-1} and \ref{itm:lem-feasible-block-sequence-properties-3-2} are analogous.
Suppose not.
Then obtain \(i\in[m]\) such that both \(\mathcal{B}(u^i,L)\geq\mathcal{B}(x^1,B)\) and \(\mathcal{B}(u^i,R)\geq\mathcal{B}(x^1,B)\).
We show that the capacity constraint for edge \((u^i,v^i)\) is violated for round \(\mathcal{B}(x^1,B)\).

We have that

1. \(\alpha_L((u^i,v^i),B_{\mathcal{B}(x^1,B)-1})=\mathrm{active}\), since \(b(u^i,L)\notin B_{\mathcal{B}(x^1,B)-1}\) and \((u^i,v^i)\in E(L^o)\),
   
2. \(\alpha_R((u^i,v^i),B_{\mathcal{B}(x^1,B)-1})=\mathrm{active}\), since \(b(u^i,R)\notin B_{\mathcal{B}(x^1,B)-1}\) and \((u^i,v^i)\in E(R^o)\), and

3. \(\alpha_B((u^i,v^i),B_{\mathcal{B}(x^1,B)})=\mathrm{active}\), since \(b(u^i,B)=b(x^1,B)\in B_{\mathcal{B}(x^1,B)}\) and \((u^i,v^i)\in E(B^u)\).

Hence
\begin{align*}
\lvert\{P\in\mathcal{P}\mid&\alpha_P((u^i,v^i),B_{\mathcal{B}(x^1,B)-1})=\mathrm{active}\text{ or }\\
&\alpha_P((u^i,v^i),B_{\mathcal{B}(x^1,B)})=\mathrm{active}\}\rvert\geq\lvert\{L,R,B\}\rvert=3>2=c(u^i,v^i)
\end{align*}

#+latex: \paragraph{\ref{itm:lem-feasible-block-sequence-properties-2}, \ref{itm:lem-feasible-block-sequence-properties-5}, \ref{itm:lem-feasible-block-sequence-properties-6}.}
We only show \ref{itm:lem-feasible-block-sequence-properties-2-1}; the proofs for \ref{itm:lem-feasible-block-sequence-properties-2-2}, \ref{itm:lem-feasible-block-sequence-properties-5-1}, \ref{itm:lem-feasible-block-sequence-properties-5-2}, \ref{itm:lem-feasible-block-sequence-properties-5-3}, \ref{itm:lem-feasible-block-sequence-properties-5-4}, \ref{itm:lem-feasible-block-sequence-properties-6-1}, and \ref{itm:lem-feasible-block-sequence-properties-6-2} are similar.
Suppose not.
Then obtain \(i\in[m]\) such that \(\mathcal{B}(\tilde{u}_L^i,\tilde{B})\geq\mathcal{B}(u^i,L)\).
We show that the capacity constraint for edge \((\tilde{u}_L^i,\tilde{v}_L^i)\) is violated for round \(\mathcal{B}(u^i,L)\).

We have that

1. \(\alpha_{\tilde{B}}((\tilde{u}_L^i,\tilde{v}_L^i),B_{\mathcal{B}(u^i,L)-1})=\mathrm{active}\), since \(b(\tilde{u}_L^i,\tilde{B})\notin B_{\mathcal{B}(u^i,L)-1}\) and \((\tilde{u}_L^i,\tilde{v}_L^i)\in E(\tilde{B}^o)\), and

2. \(\alpha_L((\tilde{u}_L^i,\tilde{v}_L^i),B_{\mathcal{B}(u^i,L)})=\mathrm{active}\), since \(b(\tilde{u}_L^i,L)=b(u^i,L)\in B_{\mathcal{B}(u^i,L)}\) and \((\tilde{u}_L^i,\tilde{v}_L^i)\in E(L^u)\).

Hence
\begin{align*}
\lvert\{P\in\mathcal{P}\mid&\alpha_P((\tilde{u}_L^i,\tilde{v}_L^i),B_{\mathcal{B}(u^i,L)-1})=\mathrm{active}\text{ or }\\
&\alpha_P((\tilde{u}_L^i,\tilde{v}_L^i),B_{\mathcal{B}(u^i,L)})=\mathrm{active}\}\rvert\geq\lvert\{\tilde{B},L\}\rvert=2>1=c(\tilde{u}_L^i,\tilde{v}_L^i)
\end{align*}

#+latex: \paragraph{\ref{itm:lem-feasible-block-sequence-properties-4}.}
Suppose not.
Then obtain \(j\in[n]\) such that both \(\mathcal{B}(x^1,B)\geq\mathcal{B}(x^j,\bar{X})\) and \(\mathcal{B}(x^1,B)\geq\mathcal{B}(x^j,X)\).
We show that the capacity constraint for edge \((x^j,y^j)\) is violated for round \(\mathcal{B}(x^1,B)\).

We have that

1. \(\alpha_B((x^j,y^j),B_{\mathcal{B}(x^1,B)-1})=\mathrm{active}\), since \(b(x^j,B)=b(x^1,B)\notin B_{\mathcal{B}(x^1,B)-1}\) and \((x^j,y^j)\in E(B^o)\),
   
2. \(\alpha_{\bar{X}}((x^j,y^j),B_{\mathcal{B}(x^1,B)})=\mathrm{active}\), since \(b(x^j,\bar{X})\notin B_{\mathcal{B}(x^1,B)}\) and \((x^j,y^j)\in E(\bar{X}^u)\), and

3. \(\alpha_{X}((x^j,y^j),B_{\mathcal{B}(x^1,B)})=\mathrm{active}\), since \(b(x^j,X)\notin B_{\mathcal{B}(x^1,B)}\) and \((x^j,y^j)\in E(X^u)\).

Hence
\begin{align*}
\lvert\{P\in\mathcal{P}\mid&\alpha_P((x^j,y^j),B_{\mathcal{B}(x^1,B)-1})=\mathrm{active}\text{ or }\\
&\alpha_P((x^j,y^j),B_{\mathcal{B}(x^1,B)})=\mathrm{active}\}\rvert\geq\lvert\{B,\bar{X},X\}\rvert=3>2=c(x^j,y^j)
\end{align*}
#+end_proof

We are now ready to prove Theorem [[thm:np-hardness-special-case]].

#+attr_latex: :options [Proof of Theorem [[thm:np-hardness-special-case]]]
#+begin_proof
We show that there is a satisfying assignment \(\sigma\) for 4CNF formula \(C\) iff there is a feasible block sequence \(\mathcal{B}\) for the corresponding update flow network \(G\), which, by Corollary [[corollary:block-sequence-iff-update-sequence]], is the case iff there is a feasible update sequence for \(G\).
We will choose \(\sigma\), \(\mathcal{B}\), respectively, such that \(\sigma\) assigns \(1\) to variable \(x_j\) iff \(\mathcal{B}(x^j,\bar{X})>\mathcal{B}(x^1,B)\).

#+latex: \paragraph{Only-if part.}
Let \(\mathcal{B}\) be a feasible block sequence for \(G\).
We define assignment \(\sigma\) as follows:
For every variable \(x_j\), we assign \(1\) to \(x_j\) iff \(\mathcal{B}(x^j,\bar{X})>\mathcal{B}(x^1,B)\).
We now show that \(\sigma\) is a satisfying assignment for \(C\).

Let \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\) be a clause.
We show that \(\sigma\) satisfies \(C_i\) by obtaining a literal that evaluates to \(1\).

Consider round \(\mathcal{B}(x^1,B)\).
By Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-1}, \(\mathcal{B}(x^1,B)>\mathcal{B}(u^i,L)\) or \(\mathcal{B}(x^1,B)>\mathcal{B}(u^i,R)\).
We only consider the former case \(\mathcal{B}(x^1,B)>\mathcal{B}(u^i,L)\); the latter one is analogous.

By Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-2-1}, \(\mathcal{B}(u^i,L)>\mathcal{B}(\tilde{u}_L^i,\tilde{B})\).
By Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-3-1}, \(\mathcal{B}(\tilde{u}_L^i,\tilde{B})>\mathcal{B}(u_L^i,\tilde{L})\) or \(\mathcal{B}(\tilde{u}_L^i,\tilde{B})>\mathcal{B}(u_L^i,\tilde{R})\).
We only consider the latter case \(\mathcal{B}(\tilde{u}_L^i,\tilde{B})>\mathcal{B}(u_L^i,\tilde{R})\); the former one is analogous.

Let \(x_j\) be the variable corresponding to literal \(l_{i_2}\).
We consider the cases \(l_{i_2}=\bar{x}_j\) and \(l_{i_2}=x_j\) separately.

Case \(l_{i_2}=\bar{x}_j\).
By Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-5-2}, \(\mathcal{B}(u_L^i,\tilde{R})>\mathcal{B}(x_0^j,B_0)\).
By Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-6-1}, \(\mathcal{B}(x_0^j,B_0)>\mathcal{B}(x^j,\bar{X})\).
Putting everything together yields the following chain of inequalities:
\[
\mathcal{B}(x^1,B)>
\mathcal{B}(u^i,L)>
\mathcal{B}(\tilde{u}_L^i,\tilde{B})>
\mathcal{B}(u_L^i,\tilde{R})>
\mathcal{B}(x_0^j,B_0)>
\mathcal{B}(x^j,\bar{X})
\]
Hence, by definition of our assignment, variable \(x_j\) is assigned \(0\).
Hence literal \(l_{i_2}=\bar{x}_j\) evaluates to \(1\).

Case \(l_{i_2}=x_j\).
By Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-5-2}, \(\mathcal{B}(u_L^i,\tilde{R})>\mathcal{B}(x_1^j,B_1)\).
By Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-6-2}, \(\mathcal{B}(x_1^j,B_1)>\mathcal{B}(x^j,X)\).
Putting everything together yields the following chain of inequalities:
\[
\mathcal{B}(x^1,B)>
\mathcal{B}(u^i,L)>
\mathcal{B}(\tilde{u}_L^i,\tilde{B})>
\mathcal{B}(u_L^i,\tilde{R})>
\mathcal{B}(x_1^j,B_1)>
\mathcal{B}(x^j,X)
\]
Hence, by Lemma [[lem:feasible-block-sequence-properties]] \ref{itm:lem-feasible-block-sequence-properties-4}, \(\mathcal{B}(x^j,\bar{X})>\mathcal{B}(x^1,B)\).
Hence, by definition of our assignment, variable \(x_j\) is assigned \(1\).
Hence literal \(l_{i_2}=x_j\) evaluates to \(1\).

#+latex: \paragraph{If part.}
Let \(\sigma\) be a satisfying assignment for \(C\).
We construct a feasible block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{11})\) for \(G\) as follows.
The basic idea is to update blocks induced by

- variable vertices corresponding to variables that are assigned \(1\) and

- clause vertices corresponding to satisfied clauses


before we update block \(b(x^1,B)\), and all other blocks afterwards.
We now specify \(\mathscr{B}_1,\dots,\mathscr{B}_{11}\) in detail.

1. For every variable \(x_j\), if \(x_j\) is assigned \(1\), we add block \(b(x^j,X)\) to \(\mathscr{B}_1\), otherwise we add \(b(x^j,\bar{X})\).
   That is,
   \[
   \mathscr{B}_1=\{b(x^j,X)\mid\sigma(x_j)=1\}\cup\{b(x^j,\bar{X}\mid\sigma(x_j)=0\}.
   \]
   
2. For every variable \(x_j\), if \(x_j\) is assigned \(1\), we add block \(b(x_1^j,B_1)\) to \(\mathscr{B}_2\), otherwise we add \(b(x_0^j,B_0)\).
   That is,
   \[
   \mathscr{B}_2=\{b(x_1^j,B_1)\mid\sigma(x_j)=1\}\cup\{b(x_0^j,B_0\mid\sigma(x_j)=0\}.
   \]

3. For every clause \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\),

   1) if \(l_{i_1}\) evaluates to \(1\), we add block \(b(u_L^i,\tilde{L})\) to \(\mathscr{B}_3\),

   2) if \(l_{i_2}\) evaluates to \(1\), we add \(b(u_L^i,\tilde{R})\),

   3) if \(l_{i_3}\) evaluates to \(1\), we add \(b(u_R^i,\tilde{L})\), and

   4) if \(l_{i_4}\) evaluates to \(1\), we add \(b(u_R^i,\tilde{R})\).

   That is,
   \begin{align*}
   \mathscr{B}_3=&\{b(u_L^i,\tilde{L})\mid\sigma(l_{i_1})=1\}\cup
   \{b(u_L^i,\tilde{R})\mid\sigma(l_{i_2})=1\}\cup\\
   &\{b(u_R^i,\tilde{L})\mid\sigma(l_{i_3})=1\}\cup
   \{b(u_R^i,\tilde{R})\mid\sigma(l_{i_4})=1\}.
   \end{align*}
   
4. For every clause \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\), if the left half \((l_{i_1}\vee l_{i_2})\) of \(C_i\) is satisfied, we add block \(b(\tilde{u}_L^i,\tilde{B})\) to \(\mathscr{B}_4\), and if the right half \((l_{i_3}\vee l_{i_4})\) is satisfied, we add \(b(\tilde{u}_R^i,\tilde{B})\).
   That is,
   \begin{align*}
   \mathscr{B}_4=&\{b(\tilde{u}_L^i,\tilde{B})\mid\sigma(l_{i_1})=1\text{ or }\sigma(l_{i_2})=1\}\cup\\
   &\{b(\tilde{u}_R^i,\tilde{B})\mid\sigma(l_{i_3})=1\text{ or }\sigma(l_{i_4})=1\}.
   \end{align*}
   
5. For every clause \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\), if the left half \((l_{i_1}\vee l_{i_2})\) of \(C_i\) is satisfied, we add block \(b(u^i,L)\) to \(\mathscr{B}_5\), and if the right half \((l_{i_3}\vee l_{i_4})\) is satisfied, we add \(b(u^i,R)\).
   That is,
   \begin{align*}
   \mathscr{B}_5=&\{b(u^i,L)\mid\sigma(l_{i_1})=1\text{ or }\sigma(l_{i_2})=1\}\cup\\
   &\{b(u^i,R)\mid\sigma(l_{i_3})=1\text{ or }\sigma(l_{i_4})=1\}.
   \end{align*}
   
6. \(\mathscr{B}_6=\{b(x^1,B)\}\).

7. For every variable \(x_j\), if \(x_j\) is assigned \(0\), we add block \(b(x^j,X)\) to \(\mathscr{B}_7\), otherwise we add \(b(x^j,\bar{X})\).
   That is,
   \[
   \mathscr{B}_7=\{b(x^j,X)\mid\sigma(x_j)=0\}\cup\{b(x^j,\bar{X}\mid\sigma(x_j)=1\}.
   \]
   
8. For every variable \(x_j\), if \(x_j\) is assigned \(0\), we add block \(b(x_1^j,B_1)\) to \(\mathscr{B}_8\), otherwise we add \(b(x_0^j,B_0)\).
   That is,
   \[
   \mathscr{B}_8=\{b(x_1^j,B_1)\mid\sigma(x_j)=0\}\cup\{b(x_0^j,B_0\mid\sigma(x_j)=1\}.
   \]

9. For every clause \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\),

   1) if \(l_{i_1}\) evaluates to \(0\), we add block \(b(u_L^i,\tilde{L})\) to \(\mathscr{B}_9\),

   2) if \(l_{i_2}\) evaluates to \(0\), we add \(b(u_L^i,\tilde{R})\),

   3) if \(l_{i_3}\) evaluates to \(0\), we add \(b(u_R^i,\tilde{L})\), and

   4) if \(l_{i_4}\) evaluates to \(0\), we add \(b(u_R^i,\tilde{R})\).

   That is,
   \begin{align*}
   \mathscr{B}_9=&\{b(u_L^i,\tilde{L})\mid\sigma(l_{i_1})=0\}\cup
   \{b(u_L^i,\tilde{R})\mid\sigma(l_{i_2})=0\}\cup\\
   &\{b(u_R^i,\tilde{L})\mid\sigma(l_{i_3})=0\}\cup
   \{b(u_R^i,\tilde{R})\mid\sigma(l_{i_4})=0\}.
   \end{align*}

1. For every clause \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\), if the left half \((l_{i_1}\vee l_{i_2})\) of \(C_i\) is unsatisfied, we add block \(b(\tilde{u}_L^i,\tilde{B})\) to \(\mathscr{B}_{10}\), and if the right half \((l_{i_3}\vee l_{i_4})\) is unsatisfied, we add \(b(\tilde{u}_R^i,\tilde{B})\).
   That is,
   \begin{align*}
   \mathscr{B}_{10}=&\{b(\tilde{u}_L^i,\tilde{B})\mid\sigma(l_{i_1})=0\text{ and }\sigma(l_{i_2})=0\}\cup\\
   &\{b(\tilde{u}_R^i,\tilde{B})\mid\sigma(l_{i_3})=0\text{ and }\sigma(l_{i_4})=0\}.
   \end{align*}

1. For every clause \(C_i=(l_{i_1}\vee l_{i_2}\vee l_{i_3}\vee l_{i_4})\), if the left half \((l_{i_1}\vee l_{i_2})\) of \(C_i\) is unsatisfied, we add block \(b(u^i,L)\) to \(\mathscr{B}_{11}\), and if the right half \((l_{i_3}\vee l_{i_4})\) is unsatisfied, we add \(b(u^i,R)\).
   That is,
   \begin{align*}
   \mathscr{B}_{11}=&\{b(u^i,L)\mid\sigma(l_{i_1})=0\text{ and }\sigma(l_{i_2})=0\}\cup\\
   &\{b(u^i,R)\mid\sigma(l_{i_3})=0\text{ and }\sigma(l_{i_4})=0\}.
   \end{align*}

By Remark [[remark:block-sequence]], we may ignore all other blocks.

We now show that block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{11})\) is feasible by verifying that the capacity constraint is satisfied for every edge and every \(\ell\in[11]\).
Since every flow pair has demand \(1\), we

- may use remark [[remark:capacity-constraint-blocks-demand-1]] again to argue about capacity constraints, and
  
- only have to consider edges with capacity less than \(10\), that is, the number of flow pairs.


For every such edge \(e\), we proceed as follows.

1. First, for every \(\ell\in\{0,\dots,11\}\) and every flow pair \(P\), we determine if \(e\) is on the transient (\(s,t\))-path for \(P\) after updating all blocks in \(B_{\ell}\), that is, we determine if \(\alpha_P(e,B_{\ell})=\mathrm{active}\).

2. Next, for every \(\ell\in\{0,\dots,11\}\), we determine the set of flow pairs \(P\) such that \(\alpha_P(e,B_{\ell})=\mathrm{active}\), that is, we determine the set \(\mathcal{P}(e,\ell):=\{P\in\mathcal{P}\mid\alpha_P(e,B_{\ell})=\mathrm{active}\}\).

3. Then, for every \(\ell\in[11]\), we determine the set \(\mathcal{P}'(e,\ell):=\mathcal{P}(e,\ell-1)\cup\mathcal{P}(e,\ell)=\{P\in\mathcal{P}\mid\alpha_P(e,B_{\ell-1})=\mathrm{active}\text{ or }\alpha_P(e,B_{\ell})=\mathrm{active}\}\).

4. Finally, for every \(\ell\in[11]\), we verify that the cardinality of the set \(\mathcal{P}'(e,\ell)\) obtained in the previous step is at most \(c(e)\).


#+latex: \paragraph{\((x^j,y^j)\)}
Let \(j\in[n]\).
Then edge \((x^j,y^j)\) is used by flow pairs \(\bar{X},X,B\).

Since \((x^j,y^j)\in E(\bar{X}^u\setminus\bar{X}^o)\), by Lemma [[lem:alpha-block-cases-edge]],
\[\alpha_{\bar{X}}((x^j,y^j),B_{\ell})=
\begin{cases}
\mathrm{active} & \text{if }\sigma(x_j)=1\text{ and }\ell\geq 7\\
\mathrm{active} & \text{if }\sigma(x_j)=0\text{ and }\ell\geq 1\\
\mathrm{inactive} & \text{otherwise}.
\end{cases}\]

Since \((x^j,y^j)\in E(X^u\setminus X^o)\), by Lemma [[lem:alpha-block-cases-edge]],
\[\alpha_X((x^j,y^j),B_{\ell})=
\begin{cases}
\mathrm{active} & \text{if }\sigma(x_j)=1\text{ and }\ell\geq 1\\
\mathrm{active} & \text{if }\sigma(x_j)=0\text{ and }\ell\geq 7\\
\mathrm{inactive} & \text{otherwise}.
\end{cases}\]

Since \((x^j,y^j)\in E(B^o\setminus B^u)\) and \(b(x^j,B)=b(x^1,B)\in\mathscr{B}_6\), by Lemma [[lem:alpha-block-cases-edge]],
\[\alpha_B}((x^j,y^j),B_{\ell})=
\begin{cases}
\mathrm{active} & \ell<6\\
\mathrm{inactive} & \ell\geq 6.
\end{cases}\]

Hence,
\[\mathcal{P}((x^j,y^j),\ell)=
\begin{cases}
\{B\} & \ell<1\\
\{X,B\} & \sigma(x_j)=1\text{ and }1\leq\ell<6\\
\{X\} & \sigma(x_j)=1\text{ and }\ell=6\\
\{\bar{X},B\} & \sigma(x_j)=0\text{ and }1\leq\ell<6\\
\{\bar{X}\} & \sigma(x_j)=0\text{ and }\ell=6\\
\{\bar{X},X\} & \ell\geq 7.
\end{cases}\]

Hence,
\[\mathcal{P}'((x^j,y^j),\ell)=
\begin{cases}
\{X,B\} & \sigma(x_j)=1\text{ and }\ell<7\\
\{\bar{X},B\} & \sigma(x_j)=0\text{ and }\ell<7\\
\{\bar{X},X\} & \ell\geq 7.
\end{cases}\]

Hence \(\lvert\mathcal{P}'((x^j,y^j),\ell)\rvert=2=c(x^j,y^j)\) for every \(\ell\in[11]\).

- [ ] Repeat for other edges.
#+end_proof

** Merging Flow Pairs

We now prove the [[lem:merging-flow-pairs][Merging Lemma]].

Let \(G=(V,E,\mathcal{P},s,t,c)\) be an update flow network with \(\lvert\mathcal{P}\rvert\geq 2\), and let \(F,F'\in\mathcal{P}\) and \(v_F,v_{F'}\in V\) such that they satisfy properties \ref{itm:lem-merging-flow-pairs-property-1}, \ref{itm:lem-merging-flow-pairs-property-2}, and \ref{itm:lem-merging-flow-pairs-property-3} (see Figure [[fig:lem-merging-flow-pairs-g]]).
We construct an update flow network \(\tilde{G}=(\tilde{V},\tilde{E},\tilde{\mathcal{P}},s,t,\tilde{c})\) with \(\lvert\tilde{\mathcal{P}}\rvert=\lvert\mathcal{P}\rvert-1\) such that there is a feasible block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) for \(G\) iff there is a feasible block sequence \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) for \(\tilde{G}\) as follows.

#+name: fig:lem-merging-flow-pairs-g
#+caption: Flow pairs \(F\) and \(F'\) in update flow network \(G\)
[[file:../assets/Screen Shot 2023-02-19 at 13.28.41.png]]

*** The Construction

Intuitively, we merge flow pairs \(F\) and \(F'\) into a single flow pair \(\tilde{F}\) by concatenating \(F\) and \(F'\).
More precisely, \(\tilde{F}\) will be the union of \(F\) and \(F'\) except that we replace edges \((v_F,t)\) and \((s,v_{F'})\) by edge \((v_F,v_{F'})\) (see Figure [[fig:lem-merging-flow-pairs-g-tilde]] for an illustration).
More formally, we define flow pair \(\tilde{F}\) as follows:

\begin{align*}
\tilde{E}(\tilde{F}^o)&=\left(E(F^o)\setminus\{(v_F,t)\}\right)\cup\left(E(F'^o)\setminus\{(s,v_{F'})\}\right)\cup\{(v_F,v_{F'})\}\\
\tilde{E}(\tilde{F}^u)&=\left(E(F^u)\setminus\{(v_F,t)\}\right)\cup\left(E(F'^u)\setminus\{(s,v_{F'})\}\right)\cup\{(v_F,v_{F'})\}\\
\tilde{V}(\tilde{F}^o)&=\tilde{V}(\tilde{E}(\tilde{F}^o))\\
\tilde{V}(\tilde{F}^u)&=\tilde{V}(\tilde{E}(\tilde{F}^u))\\
\tilde{d}_{\tilde{F}}&=d_F
\end{align*}

#+name: fig:lem-merging-flow-pairs-g-tilde
#+caption: Flow pair \(\tilde{F}\) in update flow network \(\tilde{G}\)
[[file:../assets/Screen Shot 2023-02-19 at 13.29.07.png]]

Update flow network \(\tilde{G}=(\tilde{V},\tilde{E},\tilde{\mathcal{P}},s,t,\tilde{c})\) is defined as follows:

\begin{align*}
\tilde{\mathcal{P}}&=\mathcal{P}\setminus\{F,F'\}\cup\{\tilde{F}\}\\
\tilde{V}&=\bigcup_{\tilde{P}\in\tilde{\mathcal{P}}}\tilde{V}(\tilde{P}^o\cup\tilde{P}^u)\\
\tilde{E}&=\bigcup_{\tilde{P}\in\tilde{\mathcal{P}}}\tilde{E}(\tilde{P}^o\cup\tilde{P}^u)\\
\tilde{c}(\tilde{e})&=
\begin{cases}
\sum_{\tilde{P}\in\tilde{\mathcal{P}}:\tilde{e}\in\tilde{E}(\tilde{P}^o\cup\tilde{P}^u)}\tilde{d}_{\tilde{P}} & \text{if }\tilde{e}=(v_F,v_{F'})\\
c(\tilde{e}) & \text{otherwise}
\end{cases}
\end{align*}

Let us quickly verify that \(\tilde{G}\) is a feasible update flow network.

Let \(\tilde{P}\in\tilde{\mathcal{P}}\).
If \(\tilde{P}\neq\tilde{F}\), then \(\tilde{P}\in\mathcal{P}\) and hence, by feasibility of update flow network \(G\), both \(\tilde{P}^o\) and \(\tilde{P}^u\) are \((s,t)\)-paths in \(\tilde{G}\) and \(\tilde{P}\) forms a DAG.
Now suppose \(\tilde{P}=\tilde{F}\).
By feasibility of \(G\) and construction of \(\tilde{F}\), \(\tilde{F}^o\) (\(\tilde{F}^u\)) comprises the \((s,v_F)\)-path in \(F^o\) (\(F^u\)), edge \((v_F,v_{F'})\), and the \((v_{F'},t)\)-path in \(F'^o\) (\(F'^u\)), and hence forms an \((s,t)\)-path.
Moreover, since, again by feasibility of \(G\), both \(F\) and \(F'\) form DAGs, and edge \((v_F,v_{F'})\) does not introduce a cycle, as \(F\) and \(F'\) have no common vertices other than \(s,t\) by assumption, \(\tilde{F}\) forms a DAG.

Using Lemma [[lem:update-flow-network-feasible-if]], we will show that all capacity constraits are satisfied for both the old flow network and the updated flow network in the if part of the proof of the [[lem:merging-flow-pairs][Merging Lemma]].

We denote notations such as \(b(v,P)\), \(B_i\), and \(\alpha_P(e,B)\) referring to update flow network \(\tilde{G}\) by \(\tilde{b}(v,P)\), \(\tilde{B}_i\), and \(\tilde{\alpha}_P(e,B)\).

*** The Proof

Our goal is to show that there is a feasible block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) for \(G\) iff there is a feasible block sequence \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) for \(\tilde{G}\).
We will choose \(\mathcal{B},\tilde{\mathcal{B}}\), respectively, such that, for every block \(b\) contained in both \(G\) and \(\tilde{G}\), \(b\) is updated in round \(i\in[\ell]\) in \(\mathcal{B}\) iff it is updated in round \(i\) in \(\tilde{\mathcal{B}}\), that is, \(\mathcal{B}(b)=\tilde{\mathcal{B}}(b)\).
The key insight is that it is indeed sufficient to consider such blocks.

#+name: lem:p-blocks
#+begin_lem
#+latex: ~
1. @@latex:\label{itm:lem-p-blocks-1}@@
   Let \(\tilde{u}\in\tilde{V}(\tilde{F}^o\cup\tilde{F}^u)\setminus\{v_F\}\). Then:

   1) @@latex:\label{itm:lem-p-blocks-1-1}@@
      If \(\tilde{u}\in V(F^o\cup F^u)\), then \(\tilde{b}(\tilde{u},\tilde{F})=b(\tilde{u},F)\).

   2) @@latex:\label{itm:lem-p-blocks-1-2}@@
      If \(\tilde{u}\in V(F'^o\cup F'^u)\setminus\{s\}\), then \(\tilde{b}(\tilde{u},\tilde{F})=b(\tilde{u},F')\).

2. @@latex:\label{itm:lem-p-blocks-2}@@
   For every \(\tilde{P}\in\tilde{\mathcal{P}}\setminus\{\tilde{F}\}\) and every \(\tilde{u}\in\tilde{V}(\tilde{P}^o\cup\tilde{P}^u)\), \(\tilde{b}(\tilde{u},\tilde{P})=b(\tilde{u},\tilde{P})\).
#+end_lem

- [ ] I'm pretty sure we have to exclude \(\tilde{u}=s\) in \ref{itm:lem-p-blocks-1-1}.

#+begin_remark
The proof is very technical and tedious--and hence omitted for now--and I hope we can come up with a better characterization of blocks (see [[file:../README.org::*Open problems]]) which significantly simplifies the proof.
#+end_remark

#+name: corollary:p-blocks
#+begin_corollary
#+latex: ~
1. @@latex:\label{itm:corollary-p-blocks-1}@@
   For every block \(\tilde{b}\in\tilde{B}(\tilde{G})\setminus\{\{v_F,v_{F'}\}\}\), \(\tilde{b}\in B(G)\).

2. @@latex:\label{itm:corollary-p-blocks-2}@@
   For every block \(b\in B(G)\setminus\{\{v_F,t\},\{s,v_{F'}\}\}\), \(b\in\tilde{B}(\tilde{G})\).
#+end_corollary

#+begin_proof
#+latex: ~
#+latex: \paragraph{\ref{itm:corollary-p-blocks-1}.}
Let \(\tilde{b}\in\tilde{B}(\tilde{G})\setminus\{\{v_F,v_{F'}\}\}\), \(\tilde{P}=\tilde{P}(\tilde{b})\), and \(\tilde{u}=\tilde{\mathcal{S}}(\tilde{b})\).
If \(\tilde{P}=\tilde{F}\), then, by assumption, \(\tilde{u}\neq v_F\) and hence, by construction of \(\tilde{F}\) and Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-1}, \(\tilde{b}=b(\tilde{u},F)\in B(G)\) or \(\tilde{b}=b(\tilde{u},F')\in B(G)\).
If \(\tilde{P}\neq\tilde{F}\), then, by Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-2}, \(\tilde{b}=b(\tilde{u},\tilde{P})\in B(G)\).


#+latex: \paragraph{\ref{itm:corollary-p-blocks-2}.}
Let \(b\in B(G)\setminus\{\{v_F,t\},\{s,v_{F'}\}\}\), \(P=P(b)\), and \(u=\mathcal{S}(b)\).
If \(P=F\), then, by assumption, \(u\neq v_F\) and hence, by construction of \(\tilde{F}\) and Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-1-1}, \(b=\tilde{b}(u,\tilde{F})\in\tilde{B}(\tilde{G})\).
If \(P=F'\), then, by assumption, \(u\notin\{v_F,s\}\) and hence, by construction of \(\tilde{F}\) and Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-1-2}, \(b=\tilde{b}(u,\tilde{F})\in\tilde{B}(\tilde{G})\).
If \(P\in\mathcal{P}\setminus\{F,F'\}\), then \(P\in\tilde{\mathcal{P}}\setminus\{\tilde{F}\}\) and hence, by Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-2}, \(b=\tilde{b}(u,P)\in\tilde{B}(\tilde{G})\).
#+end_proof

To show that block sequences \(\mathcal{B},\tilde{\mathcal{B}}\) as chosen above are feasible, we will verify that capacity constraint [[eqn:capacity-constraint-blocks]] is satisfied for every edge \(e\in E\), \(\tilde{e}\in\tilde{E}\), respectively, and every \(i\in[\ell]\).
We now show that for every edge \(\tilde{e}\) other than \((v_F,t),(s,v_{F'}),(v_F,v_{F'})\) and every \(i\in[\ell]\), \(\tilde{e}\) is on some transient (\(s,t\))-path in \(\tilde{G}\) after updating all blocks in \(\tilde{B}_i\) iff it is on some transient (\(s,t\))-path in \(G\) after updating all blocks in \(B_i\).

#+name: lem:alpha
#+begin_lem
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence for \(G\) and \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) be a block sequence for \(\tilde{G}\) such that for every block \(b\) contained in both \(G\) and \(\tilde{G}\), \(\mathcal{B}(b)=\tilde{\mathcal{B}}(b)\).
Moreover, let \((\tilde{u},\tilde{v})\in\tilde{E}\setminus\{(v_F,t),(s,v_{F'}),(v_F,v_{F'})\}\) and \(i\in[\ell]\).
Finally, let \(\tilde{P}\in\tilde{\mathcal{P}}\) such that \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{P}^o\cup\tilde{P}^u)\).
Then:

1. @@latex:\label{itm:lem-alpha-1}@@
   If \(\tilde{P}=\tilde{F}\), then \(\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}\) iff either \(\alpha_F((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\) or \(\alpha_{F'}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\).

2. @@latex:\label{itm:lem-alpha-2}@@
   If \(\tilde{P}\neq\tilde{F}\), then \(\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_i)\).
#+end_lem

#+begin_proof
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence for \(G\) and \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) be a block sequence for \(\tilde{G}\) such that for every block \(b\) satisfying both \(b\in B(G)\) and \(b\in\tilde{B}(\tilde{G})\), \(\mathcal{B}(b)=\tilde{\mathcal{B}}(b)\).
Let \((\tilde{u},\tilde{v})\in\tilde{E}\setminus\{(v_F,t),(s,v_{F'}),(v_F,v_{F'})\}\) and \(i\in[\ell]\).
Let \(\tilde{P}\in\tilde{\mathcal{P}}\) such that \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{P}^o\cup\tilde{P}^u)\).

#+latex: \paragraph{\ref{itm:lem-alpha-1}.}
Suppose \(\tilde{P}=\tilde{F}\).
By definition of \(\tilde{F}\) and since \((\tilde{u},\tilde{v})\in\tilde{E}\setminus\{(v_F,t),(s,v_{F'}),(v_F,v_{F'})\}\), \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{F}^o)\) iff \((\tilde{u},\tilde{v})\in E(F^o)\) or \((\tilde{u},\tilde{v})\in E(F'^o)\).
Similarly, \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{F}^u)\) iff \((\tilde{u},\tilde{v})\in E(F^u)\) or \((\tilde{u},\tilde{v})\in E(F'^u)\).
We show \(\tilde{\alpha}_{\tilde{F}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}\) iff \(\alpha_F((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\) or \(\alpha_{F'}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\).
Notice that this implies \ref{itm:lem-alpha-1}, since, by assumption, \(F,F'\) are edge-disjoint: Otherwise, either

1. \(F\) and \(F'\) have a common vertex other than \(s,t\), or
   
2. \(F^o\cup F^u\) and \(F'^o\cup F'^u\) both consist of the single edge \((s,t)\), in which case \(v_F=s\) and \(v_{F'}=t\), which contradicts that \((v_F,v_{F'})\notin E\).


We first show the if part.
Suppose \(\tilde{\alpha}_{\tilde{F}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}\).
By assumption, \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{F}^o)\) or \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{F}^u)\).
Hence \((\tilde{u},\tilde{v})\in E(F^o)\) or \((\tilde{u},\tilde{v})\in E(F^u)\) or \((\tilde{u},\tilde{v})\in E(F'^o)\) or \((\tilde{u},\tilde{v})\in E(F'^u)\).
We only consider case \((\tilde{u},\tilde{v})\in E(F^o)\); case \((\tilde{u},\tilde{v})\in E(F^u)\) is similar, and cases \((\tilde{u},\tilde{v})\in E(F'^o)\), \((\tilde{u},\tilde{v})\in E(F'^u)\) are analogous to cases \((\tilde{u},\tilde{v})\in E(F^o)\), \((\tilde{u},\tilde{v})\in E(F^u)\), respectively.

Suppose \((\tilde{u},\tilde{v})\in E(F^o)\).
Hence \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{F}^o)\).
Hence \(\tilde{b}(\tilde{u},\tilde{F})\in\tilde{B}_i\).
Moreover, by Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-1-1}, \(\tilde{b}(\tilde{u},\tilde{F})=b(\tilde{u},F)\).
Hence, by assumption, \(b(\tilde{u},F)\in B_i\).
Thus \(\alpha_F((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\).

We now show the only-if part.
Suppose \(\alpha_F((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\) or \(\alpha_{F'}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\).
We only consider the former case; the latter one is analogous.

Suppose \(\alpha_F((\tilde{u},\tilde{v}),B_i)=\mathrm{active}\).
Hence \((\tilde{u},\tilde{v})\in E(F^o)\) or \((\tilde{u},\tilde{v})\in E(F^u)\).
We again only consider the former case; the latter one is similar.

Suppose \((\tilde{u},\tilde{v})\in E(F^o)\).
Hence \(b(\tilde{u},F)\in B_i\).
Moreover, by Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-1-1}, \(b(\tilde{u},F)=\tilde{b}(\tilde{u},\tilde{F})\).
Hence, by assumption, \(\tilde{b}(\tilde{u},\tilde{F})\in\tilde{B}_i\).
Moreover, \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{F}^o)\).
Thus \(\tilde{\alpha}_{\tilde{F}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}\).

#+latex: \paragraph{\ref{itm:lem-alpha-2}.}
Suppose \(\tilde{P}\neq\tilde{F}\).
By definition of \(\tilde{G}\), \(\tilde{P}\in\mathcal{P}\setminus\{F,F'\}\) and hence both \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{P}^o)\) iff \((\tilde{u},\tilde{v})\in E(\tilde{P}^o)\) and \((\tilde{u},\tilde{v})\in\tilde{E}(\tilde{P}^u)\) iff \((\tilde{u},\tilde{v})\in E(\tilde{P}^u)\).
Hence \(\tilde{b}(\tilde{u},\tilde{P})\in\tilde{B}(\tilde{G})\) and \(\tilde{b}(\tilde{u},\tilde{P})\in B(G)\).
Hence, by assumption, \(\tilde{b}(\tilde{u},\tilde{P})\in\tilde{B}_i\) iff \(\tilde{b}(\tilde{u},\tilde{P})\in B_i\), and, by Lemma [[lem:p-blocks]] \ref{itm:lem-p-blocks-2}, \(\tilde{b}(\tilde{u},\tilde{P})=b(\tilde{u},\tilde{P})\).
Hence \(\tilde{b}(\tilde{u},\tilde{P})\in\tilde{B}_i\) iff \(b(\tilde{u},\tilde{P})\in B_i\).
The claim now follows by definitions of \(\tilde{\alpha}_{\tilde{P}},\alpha_{\tilde{P}}\).
#+end_proof

#+name: lem:sum-demands
#+begin_lem
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence for \(G\) and \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) be a block sequence for \(\tilde{G}\) such that for every block \(b\) contained in both \(G\) and \(\tilde{G}\), \(\mathcal{B}(b)=\tilde{\mathcal{B}}(b)\).
Moreover, let \((\tilde{u},\tilde{v})\in\tilde{E}\setminus\{(v_F,t),(s,v_{F'}),(v_F,v_{F'})\}\) and \(i\in[\ell]\).
Then

\begin{align*}
\sum_{\tilde{P}\in\tilde{\mathcal{P}}:\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_{i-1})=\mathrm{active}\text{ or }\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}}\tilde{d}_{\tilde{P}}&=\\
\sum_{\tilde{P}\in\mathcal{P}:\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_{i-1})=\mathrm{active}\text{ or }\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}}d_{\tilde{P}}&.
\end{align*}
#+end_lem

#+begin_proof
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a block sequence for \(G\) and \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) be a block sequence for \(\tilde{G}\) such that for every block \(b\) satisfying both \(b\in B(G)\) and \(b\in\tilde{B}(\tilde{G})\), \(\mathcal{B}(b)=\tilde{\mathcal{B}}(b)\).
Let \((\tilde{u},\tilde{v})\in\tilde{E}\setminus\{(v_F,t),(s,v_{F'}),(v_F,v_{F'})\}\) and \(i\in[\ell]\).
By definition of \(\tilde{G}\), \(\tilde{\mathcal{P}}=\mathcal{P}\setminus\{F,F'\}\cup\{\tilde{F}\}\), \(\tilde{d}_{\tilde{F}}=d_F\), and \(\tilde{d}_{\tilde{P}}=d_{\tilde{P}}\) for every \(\tilde{P}\in\tilde{\mathcal{P}}\setminus\{\tilde{F}\}\).
Moreover, by assumption, \(d_F=d_{F'}\).
Hence, by Lemma [[lem:alpha]], we have

\begin{align*}
\sum_{\tilde{P}\in\tilde{\mathcal{P}}:\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_{i-1})=\mathrm{active}\text{ or }\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}}\tilde{d}_{\tilde{P}}&=\\
\sum_{\tilde{P}\in\tilde{\mathcal{P}}\setminus\{\tilde{F}\}:\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_{i-1})=\mathrm{active}\text{ or }\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}}\tilde{d}_{\tilde{P}}&\\
+\sum_{\tilde{P}\in\{\tilde{F}\}:\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_{i-1})=\mathrm{active}\text{ or }\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}}\tilde{d}_{\tilde{P}}&=\\
\sum_{\tilde{P}\in\mathcal{P}\setminus\{F,F'\}:\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_{i-1})=\mathrm{active}\text{ or }\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}}d_{\tilde{P}}&\\
+\sum_{\tilde{P}\in\{F,F'\}:\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_{i-1})=\mathrm{active}\text{ or }\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}}d_{\tilde{P}}&=\\
\sum_{\tilde{P}\in\mathcal{P}:\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_{i-1})=\mathrm{active}\text{ or }\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}}d_{\tilde{P}}&.
\end{align*}
#+end_proof

We are now ready to prove the [[lem:merging-flow-pairs][Merging Lemma]].

#+attr_latex: :options [Proof of Lemma [[lem:merging-flow-pairs]]]
#+begin_proof
We show that there is a feasible block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) for \(G\) iff there is a feasible block sequence \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) for \(\tilde{G}\).

#+latex: \paragraph{If part.}
Let \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) be a feasible block sequence for \(G\).
We define block sequence \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) for \(\tilde{G}\) as follows.
By Remark [[remark:block-sequence]], we may ignore block \(\{v_F,v_{F'}\}\).
For every other block \(\tilde{b}\in\tilde{B}(\tilde{G})\setminus\{\{v_F,v_{F'}\}\}\), we define \(\tilde{\mathcal{B}}(\tilde{b})=\mathcal{B}(\tilde{b})\).
Notice that if \(\tilde{b}\in\tilde{B}(\tilde{G})\setminus\{\{v_F,v_{F'}\}\}\), then, by Lemma [[corollary:p-blocks]] \ref{itm:corollary-p-blocks-1}, \(\tilde{b}\in B(G)\) and hence \(\mathcal{B}(\tilde{b})\) is defined.

We now show that \(\tilde{\mathcal{B}}\) is feasible.
Let \((\tilde{u},\tilde{v})\in\tilde{E}\) and \(i\in[\ell]\).
We show that the capacity constraint for \((\tilde{u},\tilde{v})\) and \(i\) is satisfied.

If \((\tilde{u},\tilde{v})=(v_F,v_{F'})\), then, by definition of \(\tilde{G}\),
\[
\tilde{c}(\tilde{u},\tilde{v})\geq\sum_{\tilde{P}\in\tilde{\mathcal{P}}:(\tilde{u},\tilde{v})\in E(\tilde{P}^o\cup\tilde{P}^u)}d_{\tilde{P}}
\]
and hence the capacity constraint is satisfied.

Now suppose \((\tilde{u},\tilde{v})\neq(v_F,v_{F'})\).
Hence, by definition of \(\tilde{G}\), \((\tilde{u},\tilde{v})\in E\) and \(\tilde{c}(\tilde{u},\tilde{v})=c(\tilde{u},\tilde{v})\).
If \((\tilde{u},\tilde{v})\in\{(v_F,t),(s,v_{F'})\}\), then by assumption \ref{itm:lem-merging-flow-pairs-property-3-3}, the capacity constraint is satisfied.

Now suppose \((\tilde{u},\tilde{v})\notin\{(v_F,t),(s,v_{F'}),(v_F,v_{F'})\}\).
Hence, by Lemma [[lem:sum-demands]] and since block sequence \(\mathcal{B}\) is feasible, we have

\begin{align*}
\sum_{\tilde{P}\in\tilde{\mathcal{P}}:\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_{i-1})=\mathrm{active}\text{ or }\tilde{\alpha}_{\tilde{P}}((\tilde{u},\tilde{v}),\tilde{B}_i)=\mathrm{active}}\tilde{d}_{\tilde{P}}&=\\
\sum_{\tilde{P}\in\mathcal{P}:\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_{i-1})=\mathrm{active}\text{ or }\alpha_{\tilde{P}}((\tilde{u},\tilde{v}),B_i)=\mathrm{active}}d_{\tilde{P}}&\leq\\
c(\tilde{u},\tilde{v})&=
\tilde{c}(\tilde{u},\tilde{v}).
\end{align*}

#+latex: \paragraph{Only-if part.}
Let \(\tilde{\mathcal{B}}=(\tilde{\mathscr{B}}_1,\dots,\tilde{\mathscr{B}}_{\ell})\) be a feasible block sequence for \(\tilde{G}\).
We define block sequence \(\mathcal{B}=(\mathscr{B}_1,\dots,\mathscr{B}_{\ell})\) for \(G\) as follows.
By Remark [[remark:block-sequence]], we may ignore blocks \(\{v_F,t\},\{s,v_{F'}\}\).
For every other block \(b\in B(G)\setminus\{\{v_F,t\},\{s,v_{F'}\}\}\), we define \(\mathcal{B}(b)=\tilde{\mathcal{B}}(b)\).
Notice that if \(b\in B(G)\setminus\{\{v_F,t\},\{s,v_{F'}\}\}\), then, by Lemma [[corollary:p-blocks]] \ref{itm:corollary-p-blocks-2}, \(b\in\tilde{B}(\tilde{G})\) and hence \(\tilde{\mathcal{B}}(b)\) is defined.

We now show that \(\mathcal{B}\) is feasible.
Let \((u,v)\in E\) and \(i\in[\ell]\).
We show that the capacity constraint for \((u,v)\) and \(i\) is satisfied.

If \((u,v)\in\{(v_F,t),(s,v_{F'})\}\), then, by assumption \ref{itm:lem-merging-flow-pairs-property-3-3}, the capacity constraint is satisfied.

Now suppose \((u,v)\notin\{(v_F,t),(s,v_{F'})\}\).
Hence, by assumption \ref{itm:lem-merging-flow-pairs-property-3-1}, \((u,v)\notin\{(v_F,t),(s,v_{F'}),(v_F,v_{F'})\}\).
Hence, by definition of \(\tilde{G}\), \((u,v)\in\tilde{E}\) and \(c(u,v)=\tilde{c}(u,v)\).
Hence, by Lemma [[lem:sum-demands]] and since block sequence \(\tilde{\mathcal{B}}\) is feasible, we have

\begin{align*}
\sum_{P\in\mathcal{P}:\alpha_P((u,v),B_{i-1})=\mathrm{active}\text{ or }\alpha_P((u,v),B_i)=\mathrm{active}}d_P&=\\
\sum_{P\in\tilde{\mathcal{P}}:\tilde{\alpha}_P((u,v),\tilde{B}_{i-1})=\mathrm{active}\text{ or }\tilde{\alpha}_P((u,v),\tilde{B}_i)=\mathrm{active}}\tilde{d}_P&\leq\\
\tilde{c}(u,v)&=
c(u,v).
\end{align*}
#+end_proof

#+name: remark:merging-flow-pairs
#+begin_remark
Let \(G,F,F'\) and \(\tilde{G},\tilde{F}\) be as specified in the proof of the [[lem:merging-flow-pairs][Merging Lemma]].
Then notice that:

1. @@latex:\label{itm:remark-merging-flow-pairs-1}@@
   For every flow pair \(P\in\mathcal{P}\setminus\{F,F'\}\), if properties \ref{itm:lem-merging-flow-pairs-property-1}, \ref{itm:lem-merging-flow-pairs-property-2}, and \ref{itm:lem-merging-flow-pairs-property-3} are satisfied for both \(F,P\) and \(F',P\) in \(G\), then they are also satisfied for \(\tilde{F},P\) in \(\tilde{G}\).

2. @@latex:\label{itm:remark-merging-flow-pairs-2}@@
   For every two flow pairs \(P,P'\in\mathcal{P}\setminus\{F,F'\}\), if properties \ref{itm:lem-merging-flow-pairs-property-1}, \ref{itm:lem-merging-flow-pairs-property-2}, and \ref{itm:lem-merging-flow-pairs-property-3} are satisfied for \(P,P'\) in \(G\), then they are also satisfied for \(P,P'\) in \(\tilde{G}\).
#+end_remark

** \(\textbf{NP}\)-Hardness for the General Case

We are finally ready to prove Theorem [[thm:np-hardness-k-eq-3]].

#+attr_latex: :options [Proof of Theorem [[thm:np-hardness-k-eq-3]]]
#+begin_proof
Let \(C\) be a 4CNF formula and \(G\) be the corresponding update flow network as specified in the proof of Theorem [[thm:np-hardness-special-case]].
Then \(G\) comprises \(10\) flow pairs \(\bar{X},L,\tilde{L},X,R,\tilde{R},B,\tilde{B},B_0,B_1\), each with demand \(1\).

By definition, flow pairs \(\bar{X},L,\tilde{L}\) pairwise satisfy assumptions \ref{itm:lem-merging-flow-pairs-property-1}, \ref{itm:lem-merging-flow-pairs-property-2}, and \ref{itm:lem-merging-flow-pairs-property-3} of the [[lem:merging-flow-pairs][Merging Lemma]] (confirm Table [[tab:s-t-flows]]).
Hence, by Remark [[remark:merging-flow-pairs]] \ref{itm:remark-merging-flow-pairs-1}, we may apply the Merging Lemma twice to obtain from \(G\) an update flow network \(G_8\) with \(8\) flow pairs.

Similarly, flow pairs \(X,R,\tilde{R}\) pairwise satisfy assumptions \ref{itm:lem-merging-flow-pairs-property-1}, \ref{itm:lem-merging-flow-pairs-property-2}, and \ref{itm:lem-merging-flow-pairs-property-3} of the Merging Lemma in \(G\).
By Remark [[remark:merging-flow-pairs]] \ref{itm:remark-merging-flow-pairs-2}, they also satisfy these assumptions in \(G_8\).
Hence, again by Remark [[remark:merging-flow-pairs]] \ref{itm:remark-merging-flow-pairs-1}, we may apply the Merging Lemma twice to obtain from \(G_8\) an update flow network \(G_6\) with \(6\) flow pairs.

Finally, as flow pairs \(B,\tilde{B},B_0,B_1\) again pairwise satisfy all three assumptions, we apply the Merging Lemma three times to obtain from \(G_6\) an update flow network \(G_3\) with \(3\) flow pairs.

Putting everything together, we have that there is a satisfying assignment for 4CNF formula \(C\) iff there is a feasible block sequence for update flow network \(G\) iff there is a feasible block sequence for \(G_8\) iff there is a feasible block sequence for \(G_6\) iff there is a feasible block sequence for \(G_3\), which, by Corollary [[corollary:block-sequence-iff-update-sequence]], is the case iff there is a feasible update sequence for \(G_3\).
#+end_proof

* Bounded Treewidth

The goal of this section is to prove the following theorem.

#+name: thm:algorithm-bounded-treewidth-search
#+begin_thm
There is an algorithm that, given an update flow network \(G\) with \(k\) flow pairs and a nice tree decomposition of \(G\) with \(O(n)\) nodes and width \(\ell-1\), either determines that there is no feasible block sequence for \(G\) or finds such a sequence in time \(O((k\ell)!k\ell n^2)\).
#+end_thm

- [ ] Define tree decomposition of an update flow network.

  
Before we will prove how to find a feasible block sequence in section _, we will show how to decide if there is such a sequence in section _.

** Decision Problem

#+name: thm:algorithm-bounded-treewidth-decision
#+begin_thm
There is an algorithm that, given an update flow network \(G\) with \(k\) flow pairs and a nice tree decomposition of \(G\) with \(O(n)\) nodes and width \(\ell-1\), decides whether there is a feasible block sequence for \(G\) in time \(O((k\ell)!k\ell n^2)\).
#+end_thm

Let \(G\) be an update flow network with \(k\) flow pairs and \((T,\{X_x\mid x\in V(T)\})\) be a nice tree decomposition of \(G\) with \(O(n)\) nodes and width \(\ell-1\).
For a node \(x\in V(T)\), we denote by \(V_x\) the union of all bags \(X_y\) with \(y=x\) or \(y\) is a descendant of \(x\) in \(T\), and by \(G_x=(V_x,E(V_x))\) the subgraph of \(G\) induced by \(V_x\).

- [ ] Remove \(G_x\)?


The dynamic programming algorithm proceeds as follows.
For every node \(x\in V(T)\), the algorithm computes a table \(D_x\) which contains an entry \(D_x[\pi]\) for every \(X_x\)-permutation \(\pi\).
Every entry \(D_x[\pi]\) is a single bit indicating whether \(X_x\)-permutation \(\pi\) can be extended to a \(V_x\)-feasible permutation.
This is done in bottom-up order, that is, the table of node \(x\) is computed after the tables of all descendants of \(x\) have been computed.
In particular, to compute the table of node \(x\), the algorithm uses the tables of the children of \(x\).
After all tables have been computed, the algorithm can decide if there is a feasible block sequence for update flow network \(G\) as follows.

#+name: lem:root
#+begin_lem
Let \(r\) be the root of tree \(T\). Then there is a feasible block sequence for update flow network \(G\) iff \(D_r[\pi]=1\) for some \(X_r\)-permutation \(\pi\).
#+end_lem

#+begin_proof
The lemma follows immediately from \(V_r=V(G)\).
#+end_proof

In Sections _, _, _, and _, we show how to compute the table of a node in \(O((k\ell)!k\ell n)\) time for each of the four node types leaf, introduce, forget, join, before we prove Theorem [[thm:algorithm-bounded-treewidth-decision]] in Section _.

- [ ] What about empty permutations, that is, if \(X_x\subseteq\{t\}\)?

- [ ] Argue somewhere that every vertex is contained in at most \(k\) blocks.

*** Leaf Nodes

#+name: lem:leaf-nodes
#+begin_lem
Let \(x\in V(T)\) be a leaf node and \(\pi\) be an \(X_x\)-permutation.
Then \(D_x[\pi]=1\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be a leaf node.
Then bag \(X_x\) contains a single vertex and \(V_x=X_x\).
Hence \(V_x\) does not induce any edges.
Hence every \(X_x\)-permutation is \(V_x\)-feasible.
Thus \(D_x[\pi]=1\) for every \(X_x\)-permutation \(\pi\).
#+end_proof

#+name: lem:leaf-nodes-running-time
#+begin_lem
Let \(x\in V(T)\) be a leaf node.
Then the table of \(x\) can be computed in time \(O(k!)\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be a leaf node.
Then bag \(X_x\) contains a single vertex.
Hence, by Lemma [[lem:leaf-nodes]], each of the at most \((k\lvert X_x\rvert)!=k!\) entries of the table of \(x\) can be computed in \(O(1)\) time.
Thus the entire table of \(x\) can be computed in \(O(k!)\) time.
#+end_proof

*** Introduce Nodes

#+name: lem:blocks-induce-subtrees
#+begin_lem
Blocks induce subtrees.
#+end_lem

- [ ] Move.

#+name: lem:introduce-nodes-edges-v-x
#+begin_lem
\(E(V_x)=E(X_x)\cup E(V_y)\).
#+end_lem

- [ ] Move.

#+begin_proof
#+end_proof

#+name: lem:restriction-congestion-free
#+begin_lem
Let \(X\subseteq V(G)\) be a set of vertices, \(Y\subseteq X\), \(\pi\) be an \(X\)-permutation, and \(\pi'\) be the \(Y\)-restriction of \(\pi\).
If \(\pi\) is \(X\)-feasible, then \(\pi'\) is \(Y\)-feasible.
#+end_lem

- [ ] Move?

#+begin_proof
Let \(X\subseteq V(G)\) be a set of vertices, \(Y\subseteq X\), \(\pi\) be an \(X\)-permutation, and \(\pi'\) be the \(Y\)-restriction of \(\pi\).
Suppose \(\pi\) is \(X\)-feasible.
We show that \(\pi'\) is \(Y\)-feasible.

Let \(e\in E(Y)\) and \(i\in[\lvert\pi'\rvert]\).
We first show the following claim.

#+name: claim:lem-restriction-congestion-free
#+begin_claim
Let \(P\in\mathcal{P}\).
If \(\alpha_P(e,B'_i)=\mathrm{active}\), then \(\alpha_P(e,B_{\pi(\pi'_i)})=\mathrm{active}\).
#+end_claim

#+begin_proof2
Let \(u,v\in V(G)\) be two vertices such that \(e=(u,v)\) and \(P\in\mathcal{P}\).
Suppose \(\alpha_P((u,v),B'_i)=\mathrm{active}\).
If \((u,v)\in E(P^u)\) and \(b(u,P)\in B'_i\), then \(b(u,P)\in B_{\pi(\pi'_i)}\) and hence \(\alpha_P((u,v),B_{\pi(\pi'_i)})=\mathrm{active}\).
Now suppose \((u,v)\in E(P^o)\) and \(b(u,P)\notin B'_i\).
If \(b(u,P)\notin B_{\pi(\pi'_i)}\), then \(\alpha_P((u,v),B_{\pi(\pi'_i)})=\mathrm{active}\).
Now suppose \(b(u,P)\in B_{\pi(\pi'_i)}\).
Hence \(\pi(b(u,P))\leq \pi(\pi'_i)\).
Moreover, since \((u,v)\in E(Y)\), \(u\in Y\).
Since \(\pi'\) is a \(Y\)-permutation, \(b(u,P)\in S(\pi')\).
But since \(b(u,P)\notin B'_i\), \(\pi'(b(u,P))>i=\pi'(\pi'_i)\).
Hence \(\pi\) and \(\pi'\) are not consistent which contradicts that \(\pi'\) is a restriction of \(\pi\).
#+end_proof2

Since \(\pi\) is \(X\)-feasible and \(e\in E(Y)\subseteq E(X)\), by Claim [[claim:lem-restriction-congestion-free]], we have
\[
\sum_{P\in\mathcal{P}:\alpha_P(e,B'_i)=\mathrm{active}}d_P\leq\sum_{P\in\mathcal{P}:\alpha_P(e,B_{\pi(\pi'_i)})=\mathrm{active}}d_P\leq c(e).
\]
#+end_proof

- [ ] Point out that \(\pi(\pi'_i)\) is defined, as \(\pi\) is an extension of \(\pi'\).
- [ ] Define \(B'_i\).
- [ ] Argue that \(B'_i\subseteq B_{\pi(\pi'_i)}\).

#+name: lem:union-congestion-free
#+begin_lem
Let \(X,Y\subseteq V(G)\) be two sets of vertices, \(\pi\) be an \(X\)-feasible permutation, and \(\pi'\) be a \(Y\)-feasible permutation.
If \(\pi\) and \(\pi'\) are consistent, then every union of \(\pi\) and \(\pi'\) is congestion free w.r.t. \(E(X)\cup E(Y)\).
#+end_lem

- [ ] Move?

#+begin_proof
Let \(X,Y\subseteq V(G)\) be two sets of vertices, \(\pi\) be an \(X\)-feasible permutation, and \(\pi'\) be a \(Y\)-feasible permutation.
Let \(\tilde{\pi}\) be any union of \(\pi\) and \(\pi'\).
Suppose \(\pi\) and \(\pi'\) are consistent.
We show that \(\tilde{\pi}\) is congestion free w.r.t. \(E(X)\cup E(Y)\).

Let \(e\in E(X)\cup E(Y)\) and \(i\in [\lvert\tilde{\pi}\rvert]\).
We only consider the case \(e\in E(X)\); the case \(e\in E(Y)\) is similar.
Suppose \(e\in E(X)\).
Let \(j\in\{0,\dots,\lvert\pi\rvert\}\) such that \((\pi_1,\dots,\pi_j)\) is the \(X\)-restriction of \((\tilde{\pi}_1,\dots,\tilde{\pi}_i)\).
We first show the following claim.

#+name: claim:lem-union-congestion-free
#+begin_claim
Let \(P\in\mathcal{P}\).
If \(\alpha_P(e,\tilde{B}_i)=\mathrm{active}\), then \(\alpha_P(e,B_j)=\mathrm{active}\).
#+end_claim

#+begin_proof2
Let \(u,v\in V(G)\) be two vertices such that \(e=(u,v)\) and \(P\in\mathcal{P}\).
Suppose \(\alpha_P((u,v),\tilde{B}_i)=\mathrm{active}\).
If \((u,v)\in E(P^o)\) and \(b(u,P)\notin\tilde{B}_i\), then \(b(u,P)\notin B_j\) and hence \(\alpha_P((u,v),B_j)=\mathrm{active}\).
Now suppose \((u,v)\in E(P^u)\) and \(b(u,P)\in\tilde{B}_i\).
If \(b(u,P)\in B_j\), then \(\alpha_P((u,v),B_j)=\mathrm{active}\).
Now suppose \(b(u,P)\notin B_j\).
Since \((u,v)\in E(X)\), \(u\in X\).
Since \(\pi\) is an \(X\)-permutation, \(b(u,P)\in S(\pi)\).
Hence \(\pi(b(u,P))>j=\pi(\pi_j)\).
But since \(b(u,P)\in\tilde{B}_i\) and by the choice of index \(j\), \(\tilde{\pi}(b(u,P))\leq\tilde{\pi}(\pi_j)\).
Hence \(\pi\) and \(\tilde{\pi}\) are not consistent which contradicts that \(\tilde{\pi}\) is a union of \(\pi\) and \(\pi'\).
#+end_proof2

Since \(\pi\) is \(X\)-feasible and \(e\in E(X)\), by Claim [[claim:lem-union-congestion-free]], we have
\[
\sum_{P\in\mathcal{P}:\alpha_P(e,\tilde{B}_i)=\mathrm{active}}d_P\leq\sum_{P\in\mathcal{P}:\alpha_P(e,B_j)=\mathrm{active}}d_P\leq c(e).
\]
#+end_proof

- [ ] Define \(\tilde{B}_i\).
- [ ] Argue that \(B_j\subseteq\tilde{B}_i\).

#+attr_latex: :options [[cite:@amiri2016congestionfree; Lemma 4.3]]
#+name: lem:algorithm-x-feasible-permutation
#+begin_lem
Let \(X\subseteq V(G)\) be a set of vertices and \(\pi\) be an \(X\)-permutation.
Whether \(\pi\) is \(X\)-feasible can be determined in time \(O(\lvert\pi\rvert\cdot\lvert G\rvert)\).
#+end_lem

- [ ] Do we have to change the running time of the algorithm to use \(\lvert G\rvert\) instead of \(n\)?

#+attr_latex: :options
#+name: lem:introduce-nodes
#+begin_lem
Let \(x\in V(T)\) be an introduce node with child \(y\), \(\pi\) be an \(X_x\)-permutation, and \(\pi'\) be the \(X_y\)-restriction of \(\pi\).
Then \(D_x[\pi]=1\) iff \(\pi\) is \(X_x\)-feasible and \(D_y[\pi']=1\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be an introduce node with child \(y\).
Then \(X_x\supseteq X_y\) and \(V_x=X_x\cup V_y\).
Moreover, let \(\pi_{X_x}\) be an \(X_x\)-permutation and \(\pi_{X_y}\) be the \(X_y\)-restriction of \(\pi_{X_x}\).

#+latex: \paragraph{If part.}
Suppose \(D_x[\pi_{X_x}]=1\).
Then let \(\pi_{V_x}\) be a \(V_x\)-feasible extension of \(\pi_{X_x}\).
Hence, by Lemma [[lem:restriction-congestion-free]], \(\pi_{X_x}\) is \(X_x\)-feasible.
To show \(D_y[\pi_{X_y}]=1\), consider the \(V_y\)-restriction \(\pi_{V_y}\) of \(\pi_{V_x}\).
Since \(V_y\subseteq V_x\) and \(\pi_{V_x}\) is \(V_x\)-feasible, by Lemma [[lem:restriction-congestion-free]], \(\pi_{V_y}\) is \(V_y\)-feasible.
Moreover, since \(X_y\subseteq X_x\subseteq V_x\), by Lemma [[lem:three-permutations-2]] \ref{itm:lem-three-permutations-2-1}, \(\pi_{V_x}\) is a \(V_x\)-extension of \(\pi_{X_y}\).
Since \(X_y\subseteq V_y\subseteq V_x\), by Lemma [[lem:three-permutations-2]] \ref{itm:lem-three-permutations-2-2}, \(\pi_{V_y}\) is a \(V_y\)-extension of \(\pi_{X_y}\).
Thus \(D_y[\pi_{X_y}]=1\).

#+latex: \paragraph{Only-if part.}
Suppose \(\pi_{X_x}\) is \(X_x\)-feasible and \(D_y[\pi_{X_y}]=1\).
Then let \(\pi_{V_y}\) be a \(V_y\)-feasible extension of \(\pi_{X_y}\).
We show that \(\pi_{X_x}\) and \(\pi_{V_y}\) are consistent.
Then, by Lemma [[lem:union-congestion-free]], every union of \(\pi_{X_x}\) and \(\pi_{V_y}\) is congestion free w.r.t. \(E(X_x)\cup E(V_y)\), which, by Lemma [[lem:introduce-nodes-edges-v-x]], equals \(E(V_x)\).
Thus, since every union of \(\pi_{X_x}\) and \(\pi_{V_y}\) is an extension of \(\pi_{X_x}\) to blocks induced by \(X_x\cup V_y=V_x\), \(D_x[\pi_{X_x}]=1\).

Suppose not.
Then obtain blocks \(b,b'\) such that \(\pi_{X_x}(b)<\pi_{X_x}(b')\) and \(\pi_{V_y}(b)>\pi_{V_y}(b')\).
By Lemma [[lem:blocks-induce-subtrees]], both \(b\) and \(b'\) are induced by \(X_y\).
If \(\pi_{X_y}(b)<\pi_{X_y}(b')\), then \(\pi_{V_y}\) is not an extension of \(\pi_{X_y}\).
If \(\pi_{X_y}(b)>\pi_{X_y}(b')\), then \(\pi_{X_y}\) is not a restriction of \(\pi_{X_x}\).
#+end_proof

#+name: lem:introduce-nodes-running-time
#+begin_lem
Let \(x\in V(T)\) be an introduce node with child \(y\).
Given the table of \(y\), the table of \(x\) can be computed in time \(O((k\lvert X_x\rvert)!k\lvert X_x\rvert n)\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be an introduce node with child \(y\).
Lemma [[lem:introduce-nodes]] shows how to compute the table of \(x\) given the table of \(y\).
By Lemma [[lem:algorithm-x-feasible-permutation]], we can determine whether a permutation \(\pi\) is feasible in \(O(\lvert\pi\rvert n)\) time.
Moreover, we can compute any restriction of a permutation \(\pi\) in \(O(\lvert\pi\rvert)\) time.
Hence each of the at most \((k\lvert X_x\rvert)!\) entries of the table of introduce node \(x\) can be computed in \(O(k\lvert X_x\rvert n)\) time.
Thus the entire table of \(x\) can be computed in \(O((k\lvert X_x\rvert)!k\lvert X_x\rvert n)\) time.
#+end_proof

- [ ] Do we have to argue that any restriction of permutation \(\pi\) can be computed in \(O(\lvert\pi\rvert)\) time?

*** Forget nodes

#+name: lem:forget-nodes
#+begin_lem
Let \(x\in V(T)\) be a forget node with child \(y\) and \(\pi\) be an \(X_x\)-permutation. Then \(D_x[\pi]=1\) iff \(D_y[\pi']=1\) for some \(X_y\)-extension \(\pi'\) of \(\pi\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be a forget node with child \(y\).
Then \(X_x\subseteq X_y\) and hence \(V_x=V_y\).
Moreover, let \(\pi_{X_x}\) be an \(X_x\)-permutation.
The lemma follows from the following observation:
Since \(X_x\subseteq X_y\subseteq V_y=V_x\), every \(V_x\)-extension of \(\pi_{X_x}\) is the \(V_y\)-extension of some \(X_y\)-extension of \(\pi_{X_x}\).

#+latex: \paragraph{If part.}
Suppose \(D_x[\pi_{X_x}]=1\).
Then let \(\pi_{V_x}\) be a \(V_x\)-feasible extension of \(\pi_{X_x}\).
Consider the \(X_y\)-restriction \(\pi_{X_y}\) of \(\pi_{V_x}\).
Since \(X_x\subseteq X_y\subseteq V_x\), by Lemma [[lem:three-permutations-2]] \ref{itm:lem-three-permutations-2-2}, \(\pi_{X_y}\) is an \(X_y\)-extension of \(\pi_{X_x}\).
Moreover, since \(V_x=V_y\), \(\pi_{V_x}\) is a \(V_y\)-feasible extension of \(\pi_{X_y}\) and thus \(D_y[\pi_{X_y}]=1\).

#+latex: \paragraph{Only-if part.}
Suppose \(D_y[\pi_{X_y}]=1\) for some \(X_y\)-extension \(\pi_{X_y}\) of \(\pi_{X_x}\).
Then let \(\pi_{V_y}\) be a \(V_y\)-feasible extension of \(\pi_{X_y}\).
Since \(X_x\subseteq X_y\subseteq V_y\), by Lemma [[lem:three-permutations-2]] \ref{itm:lem-three-permutations-2-1}, \(\pi_{V_y}\) is a \(V_y\)-extension of \(\pi_{X_x}\).
Moreover, since \(V_x=V_y\), \(\pi_{V_y}\) is a \(V_x\)-feasible extension of \(\pi_{X_x}\) and thus \(D_x[\pi_{X_x}]=1\).
#+end_proof

#+name: alg:forget-nodes
#+begin_algorithm
\DontPrintSemicolon
\ForEach{\(X_x\)-permutation \(\pi\)}{\(D_x[\pi]\gets 0\;\)}
\ForEach{\(X_y\)-permutation \(\pi'\)}{
\If{\(D_y[\pi']=1\)}{Compute the \(X_x\)-restriction \(\pi\) of \(\pi'\)\;\label{line:alg-forget-nodes-1}\(D_x[\pi]\gets 1\)\;}
}
#+end_algorithm

- [ ] Fix rendering.


#+name: lem:forget-nodes-running-time
#+begin_lem
Let \(x\in V(T)\) be a forget node with child \(y\).
Given the table of \(y\), the table of \(x\) can be computed in time \(O((k\lvert X_y\rvert)!k\lvert X_y\rvert)\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be a forget node with child \(y\).
Then \(X_x\subseteq X_y\).
Lemma [[lem:forget-nodes]] shows how to compute table \(D_x\) given \(D_y\).
Notice, however, that an \(X_x\)-permutation may have many \(X_y\)-extensions, whereas an \(X_y\)-permutation has a unique \(X_x\)-restriction.
Hence we use the fact that permutation \(\pi'\) is an \(X_y\)-extension of \(X_x\)-permutation \(\pi\) iff \(\pi\) is the \(X_x\)-restriction of \(\pi'\) and compute table \(D_x\) using Algorithm [[alg:forget-nodes]].

We show that, given forget node \(x\) and table \(D_y\), the output \(D_x\) of Algorithm [[alg:forget-nodes]] satisfies Lemma [[lem:forget-nodes]].
Let \(\pi\) be an \(X_x\)-permutation.
If \(D_x[\pi]=0\), then \(D_x[\pi]\) was not set to \(1\) in Line \ref{line:alg-forget-nodes-1} and hence \(\pi\) is not the \(X_x\)-restriction of any \(X_y\)-permutation \(\pi'\) with \(D_y[\pi']=1\), which is the case iff there is no \(X_y\)-extension \(\pi'\) of \(\pi\) with \(D_y[\pi']=1\).
If, on the other hand, \(D_x[\pi]=1\), then there is an \(X_y\)-permutation \(\pi'\) with \(D_y[\pi']=1\) such that \(\pi\) is the \(X_x\)-restriction of \(\pi'\), which is the case iff there is an \(X_y\)-extension \(\pi'\) of \(\pi\) with \(D_y[\pi']=1\).

Since we can compute any restriction of a permutation \(\pi'\) in \(O(\lvert\pi'\rvert)\) time, Algorithm [[alg:forget-nodes]] computes the table of forget node \(x\) given the table of its child \(y\) in \(O((k\lvert X_x\rvert)!+(k\lvert X_y\rvert)!k\lvert X_y\rvert)=O((k\lvert X_y\rvert)!k\lvert X_y\rvert)\) time.
#+end_proof

*** Join nodes

#+name: lem:join-nodes-edges-v-x
#+begin_lem
\(E(V_x)=E(V_{y_1})\cup E(V_{y_2})\).
#+end_lem

- [ ] Move.

#+begin_proof
#+end_proof

#+name: lem:join-nodes
#+begin_lem
Let \(x\in V(T)\) be a join node with children \(y_1\) and \(y_2\) and \(\pi\) be an \(X_x\)-permutation.
Then \(D_x[\pi]=1\) iff both \(D_{y_1}[\pi]=1\) and \(D_{y_2}[\pi]=1\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be a join node with children \(y_1\) and \(y_2\).
Then \(X_{y_1}=X_x=X_{y_2}\) and hence \(V_x=X_x\cup V_{y_1}\cup V_{y_2}=V_{y_1}\cup V_{y_2}\).
Moreover, let \(\pi_{X_x}\) be an \(X_x\)-permutation.

#+latex: \paragraph{If part.}
Suppose \(D_x[\pi_{X_x}]=1\).
Then let \(\pi_{V_x}\) be a \(V_x\)-feasible extension of \(\pi_{X_x}\).
Consider the \(V_{y_1}\)-restriction \(\pi_{V_{y_1}}\) of \(\pi_{V_x}\).
Since \(V_{y_1}\subseteq V_x\) and \(\pi_{V_x}\) is \(V_x\)-feasible, by Lemma [[lem:restriction-congestion-free]], \(\pi_{V_{y_1}}\) is \(V_{y_1}\)-feasible.
Moreover, since \(X_x=X_{y_1}\subseteq V_{y_1}\subseteq V_x\), by Lemma [[lem:three-permutations-2]] \ref{itm:lem-three-permutations-2-2}, \(\pi_{V_{y_1}}\) is a \(V_{y_1}\)-extension of \(\pi_{X_x}\).
Thus \(D_{y_1}[\pi_{X_x}]=1\).
Analogously, \(D_{y_2}[\pi_{X_x}]=1\).

#+latex: \paragraph{Only-if part.}
Suppose both \(D_{y_1}[\pi_{X_x}]=1\) and \(D_{y_2}[\pi_{X_x}]=1\).
Then let \(\pi_{V_{y_1}}\) (\(\pi_{V_{y_2}}\)) be a \(V_{y_1}\)-feasible (\(V_{y_2}\)-feasible) extension of \(\pi_{X_x}\).
We show that \(\pi_{V_{y_1}}\) and \(\pi_{V_{y_2}}\) are consistent.
Then, by Lemma [[lem:union-congestion-free]], every union of \(\pi_{V_{y_1}}\) and \(\pi_{V_{y_2}}\) is congestion free w.r.t. \(E(V_{y_1})\cup E(V_{y_2})\), which, by Lemma [[lem:join-nodes-edges-v-x]] equals \(E(V_x)\).
Moreover, since every union \(\pi_{V_{y_1}\cup V_{y_2}}\) of \(\pi_{V_{y_1}}\) and \(\pi_{V_{y_2}}\) is an extension of \(\pi_{V_{y_1}}\) to blocks induced by \(V_{y_1}\cup V_{y_2}=V_x\), \(\pi_{V_{y_1}\cup V_{y_2}}\) is a \(V_x\)-extension of \(\pi_{V_{y_1}}\).
Hence, since \(X_x=X_{y_1}\subseteq V_{y_1}\subseteq V_x\), by Lemma [[lem:three-permutations-2]] \ref{itm:lem-three-permutations-2-1}, \(\pi_{V_{y_1}\cup V_{y_2}}\) is a \(V_x\)-extension of \(\pi_{X_x}\).
Thus \(D_x[\pi_{X_x}]=1\).

Suppose \(\pi_{V_{y_1}}\) and \(\pi_{V_{y_2}}\) are not consistent.
Then obtain blocks \(b,b'\) such that \(\pi_{V_{y_1}}(b)<\pi_{V_{y_1}}(b')\) and \(\pi_{V_{y_2}}(b)>\pi_{V_{y_2}}(b')\).
By Lemma [[lem:blocks-induce-subtrees]], both \(b\) and \(b'\) are induced by \(X_x\).
If \(\pi_{X_x}(b)<\pi_{X_x}(b')\), then \(\pi_{V_{y_2}}\) is not an extension of \(\pi_{X_x}\).
If \(\pi_{X_x}(b)>\pi_{X_x}(b')\), then \(\pi_{V_{y_1}}\) is not an extension of \(\pi_{X_x}\).
#+end_proof

#+name: lem:join-nodes-running-time
#+begin_lem
Let \(x\in V(T)\) be a join node with children \(y_1\) and \(y_2\).
Given the tables of \(y_1,y_2\), the table of \(x\) can be computed in time \(O((k\lvert X_x\rvert)!)\).
#+end_lem

#+begin_proof
Let \(x\in V(T)\) be a join node with children \(y_1\) and \(y_2\).
Lemma [[lem:join-nodes]] shows how to compute the table of \(x\) given the tables of both \(y_1\) and \(y_2\).
Hence each of the at most \((k\lvert X_x\rvert)!\) entries of the table of \(x\) can be computed in \(O(1)\) time.
Thus the entire table of \(x\) can be computed in \(O((k\lvert X_x\rvert)!)\) time.
#+end_proof

*** Putting everything together

A /postorder tree walk/ is an ordering of the nodes of a tree such that every node is later in the ordering than any of its descendants.
There are simple and well-known algorithms to find a postorder tree walk of a given tree in linear time.

In our algorithm, we compute tables for nodes in postorder, that is, first we determine a postorder tree walk for tree \(T\), and then we compute for each node \(x\in V(T)\) table \(D_x\) in this postorder.
In this way, all tables for the children of \(x\) are already computed before we compute \(D_x\), and we thus can use the methods described above to compute the tables.

Suppose \(r\) is the root of tree \(T\).
After all other tables have been computed, we compute table \(D_r\).
Given this table, we can decide if there is a feasible block sequence for update flow network \(G\).

- [ ] Edit! This is basically a copy-paste from [cite:@bodlaender2008combinatorial].

#+name: lem:root
#+begin_lem
There is a feasible block sequence for update flow network \(G\) iff \(D_r[\pi]=1\) for some \(X_r\)-permutation \(\pi\).
#+end_lem

#+begin_proof
The lemma follows immediately from \(V_r=V(G)\).
#+end_proof

#+attr_latex: :options [[[thm:algorithm-bounded-treewidth-decision]]]
#+begin_proof
Since tree decomposition \((T,\mathcal{X})\) has width \(\ell-1\), for every node \(x\in V(T)\), we can compute table \(D_x\) in \(O((k\ell)!k\ell n)\) time.
Since \((T,\mathcal{X})\) has \(O(n)\) nodes, we can compute the tables for all nodes in \(O((k\ell)!k\ell n^2)\) time.
Moreover, by Lemma [[lem:root]], given the table for the root, we can decide if there is a feasible block sequence for update flow network \(G\) in \(O((k\ell)!)\) time.
Thus the algorithm decides if there is a feasible block sequence for \(G\) in \(O((k\ell)!k\ell n^2)\) time.
#+end_proof

- [ ] Should we add lemmas for the running times?

** Search Problem
